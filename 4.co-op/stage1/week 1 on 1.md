# week 1 on 1

# performance timing 和 perdormance resource timing 的区别

1. Performance Timing是一个浏览器API，可以帮助开发者测量网页的性能，它提供了测量在文档生命周期内发生的不同事件的时间戳。我们可以使用这些时间戳来计算加载时长、解析时间、重定向时间、DNS查询时间等网页加载过程中的各项性能指标。[4]
2. Performance Resource Timing是Performance Timing API的扩展，它提供了对资源加载时间的更精确的度量，包括文件的DNS解析时间、TCP连接时间和服务器响应时间等。我们可以使用这些数据来优化网站性能，例如通过减少某些资源的大小或延迟加载以改善页面加载时间。[3]

The performance interface is a part of the High Resolution Time API. 

基于 Date 的时间精确到毫秒。但是，高分辨率时间可以精确到毫秒的分数。这非常精确，更适合用于准确测量时间。

值得注意的是，由用户代理（UA）测量的高分辨率时间不会随系统时间的任何更改而改变，因为它来自 UA 创建的全局、单调递增的时钟。时间始终在增加，无法强制减少。这对于时间测量是一个有用的约束条件。

在性能 API 中测量的每个时间都是一个高分辨率时间。这不仅使它成为测量性能的超级精确的方式，而且也是它成为高分辨率时间 API 的一部分以及我们经常看到两者一起提到的原因。

# Node vs 浏览器环境下的 performance api 有什么区别
node performance api : https://nodejs.org/api/perf_hooks.html
how to use per hooks in node : https://dev.to/bearer/measuring-performance-in-node-js-with-performance-hooks-585p

Node.js是一个服务端JavaScript环境，使用Chrome的V8引擎来运行JavaScript代码。与浏览器不同，Node.js没有DOM(Document Object Model)或BOM(Browser Object Model)，因为它并不关心文档或用户界面。相对的，在Node.js中，它提供了一些内置模块，如文件系统、网络、加密等等，这些能力帮助我们在服务器端处理数据或服务请求。

因此，Node.js中的Performance API和浏览器环境下的Performance API略有不同。在浏览器中，Performance API提供了Web应用程序性能信息的接口，例如页面加载时间、资源加载时间等。而在Node.js中，Performance API主要用于收集应用程序的指标，例如事件循环时间、CPU利用率等，以便开发人员可以优化应用程序的性能。

另外，Node.js还提供了一些专门用于性能分析的工具，例如在控制台输出的CPU分析器和堆分析器。这些工具可以帮助我们更深入地了解应用程序的性能瓶颈，并找到优化方案。

# JS 长任务有什么负面影响？
长任务是指长时间独占主线程，导致界面卡顿的 JavaScript 代码。

在加载网页时，长任务会占用主线程并使页面对用户输入无响应，即使它看起来已准备就绪。点击和轻按通常不起作用，因为尚未附加事件侦听器、单击处理程序等。

由于耗时超过 50 毫秒的复杂工作，会出现占用大量 CPU 的长任务。为什么是 50 毫秒？ RAIL 模型建议您在50 毫秒内处理用户输入事件，以确保在 100 毫秒内做出可见响应。如果你不这样做，操作和反应之间的连接就会中断。

用户注意到浏览器负载增加。在这种情况下，页面元素的点击会延迟，滚动变得卡顿，或者页面根本无响应。

此外，除了网站代码（执行JS）外，网络速度和处理能力也可能影响长任务的生成。

FID指标（首次输入延迟或与内容的第一次交互之前的等待时间）受长任务影响最大。

https://blog.clickio.com/how-long-javascript-tasks-affect-site-performance-and-what-to-do-about-it/

https://web.dev/i18n/zh/long-tasks-devtools/

# 白屏时间
https://css-tricks.com/paint-timing-api/

# 需要衡量的重要指标

https://web.dev/metrics/

1. Time to First Byte 第一字节时间 (TTFB)
2. First Contentful Paint 首次内容绘制 (FCP)
3. Largest Contentful Paint 最大内容绘制 (LCP)
4. First Input Delay 首次输入延迟 (FID)
5. Time to Interactive 可交互时间 (TTI)
6. Total Blocking Time 总阻塞时间 (TBT)
7. Cumulative Layout Shift 累积布局偏移 (CLS)
8. Interaction to Next Paint (INP)

# 怎么获取到页面每一个资源 or 接口的耗时呢？

1. 获取页面加载时间

```js
const perfData = window.performance.timing;
const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
console.log(`页面加载时间: ${pageLoadTime}ms`);
```

2. 获取资源加载时间

```js
window.performance.getEntriesByType("resource").forEach(resource => {
  console.log(`资源 ${resource.name} 的加载时间: ${resource.responseEnd - resource.requestStart}ms`);
});
```

3. 获取接口请求时间

```js
const apiRequestTime = window.performance.getEntriesByName("https://example.com/api/endpoint")[0].responseEnd - window.performance.getEntriesByName("https://example.com/api/endpoint")[0].requestStart;
console.log(`API请求时间: ${apiRequestTime}ms`);
```

# 重排/重绘
重排（Reflow）指的是浏览器重新生成布局，重新排列元素的过程。当页面发生元素的位置、尺寸、内容等方面的变化时，浏览器需要重新计算元素的大小和位置，并重新布局和绘制页面，这个过程就是重排。

重排的代价很大，会消耗大量的CPU资源，导致网页性能下降。因此，在进行DOM或样式变更时，尽量减少重排是十分重要的。具体措施包括将多次dom or 样式变更合并成一次操作、避免查询DOM太过频繁、使用CSS动画代替JavaScript动画、使用CSS transform代替改变top/left属性等。

重绘（Repaint）指的是浏览器重新绘制页面上的元素，但不涉及到元素位置、尺寸等方面的变化。当页面发生颜色、背景、文本等方面的变化时，浏览器需要重新绘制这些元素，这个过程就是重绘。可以参考[1]。

与重排相比，重绘的代价更小，因为它只需要重新绘制页面上的元素，而不需要重新计算元素的大小和位置。但是，重绘也会消耗一定的CPU资源，所以尽量减少不必要的重绘是网页性能优化的一个方向。可以通过使用CSS的will-change属性、缓存图片等方式减少不必要的重绘。

1. CPU资源消耗：重排过程中，浏览器需要重新计算元素的大小和位置，并重新布局和绘制页面，这会消耗大量的CPU资源。
2. 用户体验：重排会导致页面卡顿、滚动不流畅等不良用户体验，影响网页质量和用户满意度。
3. 渲染性能：重排会导致渲染性能下降，因为重新绘制整个页面需要消耗更多的时间和资源。

# 假如必须做一些 dom or 样式变更，怎么尽量减少重排带来的性能损耗
1. 批量操作DOM：在做多个DOM操作时，尽量减少对DOM的读取和写入次数，可以先将所有DOM修改操作进行缓存，最后一次性执行，这样可以减少浏览器对DOM的计算和渲染次数。

2. 使用虚拟DOM：通过使用虚拟DOM来对页面进行更新，可以将对DOM的更新操作转化为JS对象的操作，从而避免不必要的重排。

   虚拟DOM（Virtual DOM）的主要作用是在DOM树和应用程序状态之间建立一个抽象层。它通过在内存中维护一个虚拟的DOM树，每次状态更新时，会先对虚拟DOM进行修改，然后通过比较新旧虚拟DOM树之间的差异来计算出需要更新的最小DOM操作，最后只更新需要变化的部分。

   使用虚拟DOM的主要优势是可以避免大量的重排（Reflow）和重绘（Repaint）操作，从而提高应用程序的性能。

   重排和重绘是由于浏览器在渲染页面时需要计算元素的布局和样式，当DOM树的结构或样式发生变化时，浏览器需要重新计算元素的布局，然后重绘整个页面。这些计算和操作是非常昂贵的，特别是在大型应用程序中。

   使用虚拟DOM可以将大量的DOM操作缩减为最小限度，从而减少重排和重绘的次数。虚拟DOM会将新旧DOM树之间的差异计算出来，然后只更新需要变化的部分，这样就可以避免整个页面的重新渲染，从而提高性能。

3. 缓存布局信息：在计算元素的布局信息时，避免多次计算，可以将布局信息缓存起来，避免重复计算。

   缓存布局信息的主要思路是尽可能地减少访问DOM的次数。因为访问DOM的操作比较耗时，所以我们可以将DOM的布局信息缓存下来，减少对DOM的访问次数。

   1. 一次性访问：如果需要访问多个元素的布局信息，建议将它们一次性访问完，而不是分开访问。因为每次访问都需要重新计算布局信息，所以分开访问会增加计算的次数。
   2. 批量读写：如果需要多次访问某个元素的布局信息，可以将这些访问操作进行批量读写。例如，先将所有要读取的属性存储到变量中，然后一次性读取它们，这样可以减少对DOM的访问次数。
   3. 缓存计算结果：将布局信息的计算结果缓存到变量中，避免多次计算。如果需要多次使用相同的布局信息，可以将这些信息缓存起来，避免重复计算。
   4. 减少DOM访问：尽量减少对DOM的访问，避免不必要的DOM操作。例如，使用事件代理来监听多个元素的事件，而不是为每个元素都绑定一个事件监听器。

4. 最小化样式更改：当必须更改元素的样式时，尽量只更改必要的样式，避免不必要的样式更改，可以通过使用CSS类来集中处理样式更改。

   1. 减少计算量：浏览器在进行重排重绘时需要重新计算元素的位置和大小，而样式更改是导致重排重绘的一个重要原因。如果样式更改的范围比较小，浏览器只需要计算和绘制受影响的元素，就可以完成重排重绘的过程。而如果样式更改的范围比较大，浏览器需要重新计算和绘制整个文档树，从而增加了重排重绘的开销。
   2. 减少IO操作：当样式表文件比较大时，浏览器需要从服务器下载并解析整个样式表文件。如果在每次样式更改时都需要重新下载和解析整个样式表文件，会增加IO操作的开销，降低页面的性能。最小化样式更改可以减少样式表文件的大小，从而减少IO操作的开销，提高页面的性能。
   3. 提高渲染性能：当浏览器进行重排重绘时，需要重新计算并绘制整个文档树，这个过程比较耗时。最小化样式更改可以减少文档树的规模，从而减少重排重绘的时间，提高渲染性能。

5. 使用CSS3动画：使用CSS3动画可以避免频繁的DOM操作，从而减少重排的次数。

   1. 使用硬件加速：CSS3动画可以使用硬件加速来进行渲染，从而提高动画的性能。使用硬件加速可以将动画的渲染放到GPU中进行处理，而不是CPU，这样可以大大减少CPU的负载，避免出现卡顿和掉帧的情况。
   2. 避免多次重排和重绘：使用CSS3动画可以避免多次重排和重绘，因为动画的渲染是在GPU中进行的，不会影响到DOM的布局和渲染。相比于使用JavaScript来手动修改样式，使用CSS3动画可以更加精确地控制动画的效果，避免不必要的DOM操作。
   3. 使用Transform和Opacity：使用Transform和Opacity这两个属性来实现动画可以更加高效。因为它们可以在不影响其他元素的情况下对元素进行变换和透明度调整，避免了DOM的重排和重绘。
   4. 使用requestAnimationFrame：在进行CSS3动画时，建议使用requestAnimationFrame方法来执行动画。这个方法会在浏览器下一次重排前执行动画，从而避免了多次重排的发生。相比之下，使用setTimeout或setInterval方法来执行动画，可能会导致多次重排的发生。

6. 减少布局嵌套：嵌套过多的布局会增加重排的次数，尽量将布局嵌套层次保持在较低的水平。

   1. 减少计算量：浏览器在进行重排时需要重新计算元素的位置和大小，如果嵌套层级太多，就需要进行多次计算，从而增加了重排的开销。减少布局嵌套可以减少计算量，从而减少重排的发生。
   2. 降低耦合性：布局嵌套层级越多，元素之间的耦合性就越高。当一个元素的布局发生变化时，可能会影响到其父元素、兄弟元素甚至整个页面的布局，从而导致多次重排重绘的发生。减少布局嵌套可以降低元素之间的耦合性，减少重排重绘的次数。
   3. 提高渲染性能：当浏览器进行重排时，需要重新计算并绘制整个文档树，这个过程比较耗时。减少布局嵌套可以缩小文档树的规模，从而减少重排重绘的时间，提高渲染性能。

# http

## http2 下，减少 http 请求是否还能优化性能

在HTTP/2协议下，减少HTTP请求仍然可以优化网页性能，但是由于HTTP/2协议支持多路复用和服务器推送等功能，减少HTTP请求的优化效果可能不如在HTTP/1.x协议下显著。

HTTP/2的多路复用功能允许在一个TCP连接上同时发送多个请求和响应，从而减少了TCP连接的数量和时间。这意味着在HTTP/2下，合并小的资源（例如CSS和JS文件）成为更大的文件可能没有太大的优化效果，因为这些文件可以在同一个TCP连接中并行下载。

此外，HTTP/2协议还支持服务器推送，即服务器在响应客户端请求时主动推送相关资源，从而避免了客户端发起多个请求。例如，在服务器响应HTML页面时，可以主动推送相关的CSS和JS文件，从而减少页面加载时间。

因此，在HTTP/2协议下，尽管减少HTTP请求仍然可以优化网页性能，但是优化策略需要与HTTP/2协议的特点相结合，例如合理利用多路复用和服务器推送等功能，以获得更好的优化效果。

## HTTP 缓存有什么规则？

HTTP缓存有以下规则：

1. 强缓存：浏览器在向服务器发送请求前，会先查看本地的缓存是否存在可用的缓存资源。如果存在，且资源未过期（过期时间根据Cache-Control和Expires字段指定），则直接从缓存中取出资源并使用，不再向服务器发送请求。强缓存优先级高于协商缓存。

2. 协商缓存：如果缓存资源已经过期或不存在，则向服务器发送请求。服务器在响应头中添加Last-Modified和Etag两个字段，浏览器将这些字段值和之前请求中保存的值进行比对，如果都没有发生变化，则提示浏览器可以使用缓存，否则返回服务器的最新数据。Etag的优先级高于Last-Modified。
HTTP缓存可复用性很高，有助于提高网页性能，减轻服务器负担。应用程序可以设置缓存策略来控制缓存行为，比如设置Cache-Control、Expires、Pragma等HTTP头部字段。

## HTTP缓存相关的头部字段有：

| Header            | 作用                                                         |
| ----------------- | ------------------------------------------------------------ |
| Cache-Control     | 用于控制缓存行为，比如max-age（指定缓存过期时间）、no-cache（强制每次向服务器验证缓存）等。 |
| ETag              | 标识缓存资源的版本号，服务器通过比对ETag值来判断资源是否有更新。 |
| Expires           | 指定缓存过期时间，是一个HTTP日期格式的时间戳。               |
| Last-Modified     | 指示资源的最后修改时间，若资源被修改，则Last-Modified随之改变。 |
| If-Modified-Since | 和Last-Modified配合使用，客户端发送请求时添加该字段来告知服务器缓存资源的最后修改时间，服务器若发现资源未修改，则返回304 Not Modified。 |
| If-None-Match     | 和ETag配合使用，客户端发送请求时添加该字段来告知服务器缓存资源的版本号，服务器若发现版本未更新，则返回304 Not Modified。 |
| Vary              | 用于控制不同客户端或者代理缓存资源的策略，如Vary: User-Agent，表示根据浏览器的类型来缓存资源。 |

ref:

1. https://juejin.cn/post/6844903564679053325
2. https://www.keycdn.com/blog/http-cache-headers
3. https://www.holisticseo.digital/pagespeed/cache-control/

## http 数量多 vs 少的实际效果

HTTP请求数量对网页性能的影响是很大的，因为每个HTTP请求都会增加页面加载时间，而这种增加时间是线性的。

当网页中包含大量的HTTP请求时，会导致网页加载时间变慢，因为每个请求都需要建立TCP连接、发送请求、等待响应、接收响应等一系列操作，这些操作都需要消耗时间和资源。此外，HTTP请求也会增加网络延迟和丢包的风险，从而进一步增加页面加载时间。

另一方面，减少HTTP请求数量可以显著提高网页的性能。合并和压缩资源、使用缓存、使用CSS Sprites等技术都可以减少HTTP请求的数量，从而加速网页加载时间。

因此，应该尽量减少HTTP请求数量，但这并不意味着所有情况下都应该尽可能减少HTTP请求数量。有时候，为了更好的网页性能和用户体验，可能需要增加一些HTTP请求，例如使用异步加载、延迟加载等技术。在实际开发中，需要综合考虑网页的性能和用户需求来决定HTTP请求数量的最佳数量。

HTTP请求中的数量多与少在实际效果上有以下几个方面的差异：

响应速度：当HTTP请求数量较多时，每个请求都需要建立连接、传输数据、断开连接等过程，这样就会降低服务器的响应速度，导致网页的加载速度变慢。

网络带宽：当HTTP请求数量较多时，会占用更多的网络带宽资源，从而影响用户对其他网络应用的使用。

服务器压力：当HTTP请求数量过多时，会增加服务器的负载压力，如果服务器不能满足高并发的请求需求，就会导致系统宕机、崩溃等问题。

因此，为了提高网站的性能，一般采用优化HTTP请求的方式，如合并、压缩、缓存等技术，尽可能减少HTTP请求数量，提高网站的响应速度和用户体验。

## 如果我要请求10000条数据，是做两次请求去并发请求好，还是只做一次请求对浏览器的性能好

在请求大量数据时，将其拆分为多个请求并发处理，可以提高数据加载的速度，因为现代浏览器支持并发请求，可以同时处理多个请求，从而缩短数据加载的时间。

如果将数据全部请求一次，可能会导致浏览器长时间阻塞，因为浏览器需要等待服务器响应所有数据才能继续处理其他事情，这样会占用大量的内存和网络带宽资源，影响页面的交互性能和用户体验。

因此，将数据拆分为多个请求并发处理是更好的选择，可以将大数据量分成多个小块，分批加载，从而提高数据加载的速度和响应速度。但是，在分批请求数据时，也需要考虑每个请求的数据量、请求间隔时间等因素，以充分利用浏览器并发请求的优势，同时避免对服务器和网络造成过大的压力。

# 优化

## 压缩代码和文件

减少文件的大小：压缩代码和文件可以减少文件的大小，从而减小下载和传输的时间。尤其是对于网页加载来说，采用压缩方式可以减少页面的大小，从而加快页面加载速度。

减少网络带宽：压缩可以减小数据传输的大小，从而减少网络带宽的使用量，降低网络传输成本。特别是对于移动设备等带宽有限的场景来说，采用压缩方式可以大幅减少数据传输的大小，提高用户体验。

减少服务器负担：压缩可以减小文件的大小，从而减少服务器传输的数据量，降低服务器的负担。这样可以使服务器能处理更多的请求，提高应用程序的响应速度和并发能力。

如何压缩

对于代码文件，压缩通常是通过删除代码中的注释、空格和换行符等无关紧要的字符来实现的，从而减小文件大小。对于图片、视频和音频等二进制文件，压缩则是通过对文件进行编码压缩来实现的，从而减小文件大小。

减少文件大小可以减少文件的下载时间和传输时间，因为文件大小决定了传输时间的大小，而传输时间则会影响网页的加载速度。此外，较小的文件大小也可以减少网络带宽的使用，从而降低服务器和客户端的负担，提高网站的性能。

JavaScript中压缩文件和代码的方法可以使用专门的压缩工具或库，例如 UglifyJS、Terser、Closure Compiler 等等。这些工具在压缩 JavaScript 代码时可以实现语法分析、语义理解和优化，从而减小文件大小、提高性能。压缩后的 js 文件可以在网页上加载更快，提高用户体验。
http://www.1zh.tech/hello-webpack/content/optimize/decrease-frontend-size.html

## 减少HTTP请求

减少 HTTP 请求是优化浏览器性能的一种常见方法，通过减少请求的数量可以提高网页的加载速度并降低网页的响应时间。在用户访问网页时，浏览器需要从服务器下载相关的 HTML、CSS、JavaScript、图片等资源，每一个资源都需要发起一次 HTTP 请求，并且每次请求都需要经过网络传输，经过解析等多个步骤才能得到最终结果，这些步骤都会耗费客户端和服务器的资源。如果网页中存在大量的资源，那么就会产生过多的 HTTP 请求，进而导致浏览器响应变慢，用户体验下降。

因此，减少 HTTP 请求的数量可以大大提高网页的性能和用户体验。具体做法可以包括以下几种方式：

删除不必要的图像、CSS 文件、JavaScript 文件等无用资源。

合并多个资源文件为一个文件，减少 HTTP 请求数量。

将小的图片合成一张大图使用 CSS Sprites 技术，减少 HTTP 请求次数。

使用浏览器缓存来减少重复的 HTTP 请求。

##  使用CDN

1. 加速文件传输：CDN将网站的静态资源（如图片、CSS、JavaScript等）缓存在全球多个节点的服务器上，当用户请求访问这些资源时，会从距离用户最近的节点上获取，而不是直接从源服务器上获取，从而减少了文件传输的距离和时间，提高了文件的下载速度。
2. 减轻源服务器负担：由于CDN可以缓存网站的静态资源，因此，当用户请求访问网站时，不会直接请求源服务器上的资源，而是请求距离最近的CDN节点上的缓存资源，从而减轻了源服务器的负担，提高了网站的响应速度。
3. 提高网站的可用性：CDN节点通常部署在全球各个地区的多个地点上，如果某个节点发生故障或不可用，用户仍可以从其他节点获取资源，从而保证网站的可用性和稳定性。
4. 减少带宽消耗：由于CDN可以将网站的静态资源缓存在节点上，因此可以减少带宽的消耗，节省服务器和带宽资源，降低了网站的成本。

----

要使用 CDN（内容分发网络），可以按照以下步骤进行：

注册 CDN 服务商并购买 CDN 服务。

添加需要加速的域名或资源。在 CDN 服务商的控制面板中，添加需要加速的域名或资源，并设置相应的加速规则。

将域名解析到 CDN 服务商提供的 CNAME。

配置 CDN 加速。根据实际需求，配置 CDN 缓存策略、协议类型、SSL 等。

测试 CDN 加速效果。

需要注意的是，使用 CDN 服务需要一定的费用支出，并需确保 CDN 服务商的可靠性和安全性。

此外，不同的 CDN 服务商提供的具体操作步骤可能会有所差异，建议详细参考相应的官方文档和操作指南。

综上所述，要使用 CDN 可以购买 CDN 服务，添加需要加速的域名或资源，将域名解析到 CDN 服务商提供的 CNAME，配置 CDN 加速，并进行测试。

## 减少DOM操作,减少重绘和回流

减少DOM操作能优化性能，主要是因为DOM操作会引起浏览器的回流和重绘，从而消耗大量的计算资源和时间。当DOM结构较为复杂，DOM元素数量较多时，这种影响会更加显著。

而使用伪元素、阴影实现的内容，可以避免引入新的DOM元素，从而减少DOM操作；按需加载可以减少不必要的渲染；结构合理、语义化标签可以让DOM结构更为简洁明了。

比如对于大量DOM时的优化，可以使用文中提到的“批量操作”和“缓存”的方法，避免对DOM进行过多的读取和写入操作，从而提升性能。而虚拟DOM则是将DOM结构转换为JavaScript对象，通过比较前后两个JavaScript对象的差异，最终只对有变化的部分进行真正的DOM操作，避免了大量的无效操作，进一步提高了性能。


## 使用缓存
使用缓存可以优化性能，因为缓存可以将数据保存在内存中，下次需要使用该数据时可以直接从缓存中读取，而无需再次查询数据库或执行复杂的计算操作。这样可以大大提高数据访问的速度和效率，减少系统的负载压力，并且可以降低系统的响应时间，提升用户体验。在高并发的场景下，适当地使用缓存可以显著降低数据库的访问量，避免数据库的崩溃或性能下降，在一定程度上保证系统的稳定性和可靠性。

同时，在缓存的使用过程中，还需要注意缓存的失效策略和缓存的更新机制。合理设置缓存的生命周期可以避免过期数据的影响，而及时更新缓存可以确保数据的实时性和准确性。因此，使用缓存能优化性能是因为它有效地减少了系统的计算和IO开销，提高了数据的访问速度和效率，从而提升了系统的性能和吞吐量

1. 减少网络请求：浏览器在加载一个网页时需要请求服务器获取各种资源，如HTML、CSS、JavaScript、图像等。如果这些资源已经被缓存，则浏览器可以直接从缓存中获取资源，而无需再次向服务器发送请求，从而减少网络传输和延迟时间。
2. 减少服务器负载：当浏览器使用缓存时，服务器不再需要为每个请求提供资源，从而减少服务器的负载。这可以减少服务器的响应时间，提高网站的可用性和可靠性。
3. 减少页面加载时间：使用缓存可以减少页面加载时间，从而提高用户体验和满意度。当浏览器从缓存中获取资源时，资源可以快速加载并显示，而无需等待服务器响应，从而使页面加载更快。
4. 减少带宽成本：使用缓存可以减少带宽成本，因为缓存可以减少网络传输的数据量。如果每个用户都需要下载相同的资源，那么使用缓存可以避免多次下载相同的资源，从而减少带宽成本。

使用缓存是一种优化性能的有效方式，可以减少数据访问的延迟时间。以下是几种使用缓存来优化性能的方法：

1. 浏览器缓存：浏览器缓存是浏览器内置的缓存机制，用于将已经访问过的资源（如图片、CSS、JavaScript等）保存在本地，当用户再次访问该资源时，可以直接从缓存中获取，从而减少了请求次数，提高了网页的加载速度。浏览器缓存可以通过设置HTTP头部信息，例如 Cache-Control、Expires、Last-Modified 和 ETag 等来进行配置。
2. 服务器端缓存：服务器端缓存是将动态生成的页面或资源缓存到服务器端，当用户再次访问该资源时，可以直接从缓存中获取，减少服务器的压力和网络带宽的消耗，提高了网站的性能和稳定性。服务器端缓存可以采用诸如 Memcached、Redis 等缓存服务器，或者使用服务器自带的缓存功能（例如 ASP.NET 中的输出缓存和片段缓存）等进行配置。
3. CDN缓存：CDN缓存是将网站的静态资源分发到全球各地的CDN节点中，当用户访问该资源时，可以从离用户最近的节点获取资源，从而减少了请求时间和带宽消耗，提高了网站的访问速度和稳定性。CDN缓存可以通过配置CDN服务商提供的缓存策略，例如设置缓存过期时间、设置缓存规则、设置缓存区域等方式进行配置。
4. 数据库缓存：数据库缓存是将数据库中经常访问的数据缓存到内存中，当用户访问该数据时，可以直接从缓存中获取，减少了数据库的访问次数，提高了网站的访问速度和性能。数据库缓存可以采用内存数据库（例如 Redis）或者数据库缓存插件（例如 MySQL的 Query Cache）等进行配置。
5. Web Storage缓存：Web Storage缓存是浏览器提供的一种新型缓存机制，通过在浏览器端缓存数据，可以在用户访问时直接从缓存中获取，提高了网站的性能和体验。Web Storage缓存包括了localStorage和sessionStorage两种，可以通过HTML5提供的localStorage和sessionStorage API进行使用。

## 异步加载

1. 减少页面加载时间：当页面需要加载大量JS脚本时，如果不使用异步加载，页面需要等待JS文件全部下载完毕并解析执行后才能继续渲染。而异步加载能够让页面在下载和执行JS文件的同时继续渲染，减少页面加载时间，提高用户体验。
2. 减轻服务器压力：使用异步加载可以将页面资源分成多个请求进行加载，而不是一次性加载所有资源。这样能够减轻服务器的压力，避免因大量请求而导致服务器响应缓慢的情况。
3. 提高网站的可维护性和可扩展性：使用异步加载可以将页面的不同部分进行分离，每个部分可以单独进行开发和维护。这样能够降低代码的耦合度，提高代码的可维护性和可扩展性。
4. 动态加载数据：通过异步加载技术，可以在页面加载完成后再动态加载数据。这样能够降低页面的初次加载时间，同时也能够在数据准备好后再进行展示，提高用户体验。
5. 优化资源利用率：使用异步加载可以优化资源利用率，当网页需要加载的JavaScript文件比较多时，可以优先加载页面所需的核心JavaScript文件，而不必加载所有的JavaScript文件，从而减少不必要的网络请求和资源浪费。

要实现异步加载以优化浏览器性能，可以通过以下几种方式：

实现异步加载以优化浏览器性能的方式有以下几种：

1. defer属性：可以将JavaScript文件的下载与HTML文档的解析分开进行，等到HTML文档解析完毕后再执行JavaScript文件，从而避免阻塞页面的渲染。使用方式为在script标签中添加defer属性，如：

   ```js
   <script defer src="example.js"></script>
   ```

2. async属性：可以异步下载JavaScript文件，不会阻塞页面的解析和渲染。当JavaScript文件下载完毕后，立即执行文件中的代码，但是执行顺序不确定。使用方式为在script标签中添加async属性，如：

   ```js
   <script async src="example.js"></script>
   ```

3. 动态加载：可以在页面加载完毕后，使用JavaScript动态加载JavaScript文件，从而避免阻塞页面的渲染和用户操作。使用方式为使用document.createElement('script')创建script标签，设置标签的src属性，并将标签插入到DOM中，如：

   ```js
   var script = document.createElement('script');
   script.src = 'example.js';
   document.body.appendChild(script);
   ```

4. 懒加载：可以将JavaScript文件的下载与执行延迟到需要使用的时候再进行，从而避免不必要的网络请求和资源浪费。使用方式为在需要使用JavaScript功能的地方，动态加载JavaScript文件，如：

   ```js
   function doSomething() {
     var script = document.createElement('script');
     script.src = 'example.js';
     document.body.appendChild(script);
     // 执行JavaScript功能
   }
   ```

5. 使用模块化加载器：使用模块化加载器如RequireJS、SystemJS等，可以实现JavaScript模块的异步加载和按需加载，从而提高页面的加载速度和资源利用率。

6. 使用XMLHttpRequest对象异步加载JavaScript文件：使用XMLHttpRequest对象可以异步加载JavaScript文件，不影响页面渲染，提高页面加载速度。

   ```js
   var xhr = new XMLHttpRequest();
   xhr.open('GET', 'example.js', true);
   xhr.onload = function() {
     var script = document.createElement('script');
     script.type = 'text/javascript';
     script.text = xhr.responseText;
     document.body.appendChild(script);
   };
   xhr.send();
   // 加载的JavaScript文件必须是符合跨域规则的，否则会因为同源策略而加载失败。
   ```

   

## 图片优化（懒加载、预加载和分步加载）

懒加载：也称为延迟加载，在用户需要访问图片或其他资源时才进行加载，而不是在页面刚加载时就全部加载完。这样可以大大减少页面的加载量和请求次数，提高页面的响应速度和性能。实现懒加载可以使用一些通用的库，如 jQuery Lazyload，或根据具体需求进行编写。


预加载：在页面初始化时就开始加载未呈现的资源，以便用户在需要时能够快速访问。与懒加载相反，预加载可以使得整个页面的资源都在较短时间内加载完成，从而快速呈现给用户。常用的实现方式包括使用 link 标签的 preload 属性、动态创建 img 和 script 标签等。

<!-- 分步加载：将页面内容按照优先级进行分类，优先加载用户当前最需要的关键内容，再进行后续内容的加载。这样可以使用户快速看到重要信息，快速建立对页面的理解和信任感，提高使用效率和满意度。 -->

### 如何实现懒加载

使用 Intersection Observer API：该 API 可以监测元素是否进入了视口（即可视区域），当元素出现在视口中时才会触发加载事件，从而实现懒加载。这种方法需要浏览器支持 Intersection Observer API。

使用 getBoundingClientRect() 方法：该方法可以获取元素相对于视口的位置和大小信息，通过判断元素是否进入可视区域来触发加载事件。这种方法需要动态计算元素与视口的位置和大小，并且如果有多个元素需要进行懒加载时，代码较为复杂。

使用 jQuery Lazyload 等库：这类库提供了封装好的懒加载功能，只需配置一些参数即可实现，如图片加载时的占位符等。

### 如何实现预加载

预加载是一种优化网页性能的方式，它可以提前请求需要的资源并缓存到本地，以便在后面需要使用时能够快速加载。以下是实现预加载的一些方法：

使用 <link> 标签的 preload 属性：这是 HTML5 标准引入的一种方式，可以在 <link> 标签中通过设置 rel="preload" 来实现预加载。例如，可以在页面头部添加如下代码预加载一个 CSS 文件：

```js
<link rel="preload" href="example.css" as="style">
```

使用 JavaScript 动态创建 <link> 标签预加载资源：通过 JavaScript 动态创建 <link> 标签来实现预加载，在需要的时候将资源添加到页面中。例如，下面的代码可以预加载一个图片：

```js
var img = new Image();
img.src = "example.jpg";
```

使用 Webpack 等打包工具进行预加载：Webpack 可以通过 import() 和 require.ensure() 方法实现按需加载和预加载。例如，下面的代码可以预加载一个组件：

`import(/* webpackPrefetch: true */ './example.js');`


## 节流防抖

因为在一些需要响应用户操作的场景中，比如滚动条滚动、搜索框输入等，如果直接绑定事件处理函数，事件触发频率很高，就会导致大量的计算和渲染操作，从而降低前端性能。这时候，采用节流（throttle）和防抖（debounce）的技术可以避免重复触发事件，从而减少频繁的计算和渲染，提高性能。

节流和防抖的原理分别是将多次触发事件的执行函数变成只执行一次或者每隔一定时间执行一次。在使用防抖的情况下，当用户在搜索框中连续输入的时候，只有当用户停止输入一段时间之后，才会触发一次搜索事件，避免了频繁的请求操作，提高了性能。同理，在使用节流的情况下，当用户连续滚动页面时，只有每隔一定时间才会触发一次滚动事件，避免了重复的计算和页面渲染操作，提高了性能。

```js
function throttle(func, delay) {
  let lastTime = 0;
  return function() {
    const now = Date.now();
    if (now - lastTime > delay) {
      func.apply(this, arguments);
      lastTime = now;
    }
  };
}
```

```js
function debounce(func, delay) {
  let timer = null;
  return function() {
    clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(this, arguments);
    }, delay);
  };
}
```

