# week 1 on 1

# performance timing 和 perdormance resource timing 的区别

1. Performance Timing是一个浏览器API，可以帮助开发者测量网页的性能，它提供了测量在文档生命周期内发生的不同事件的时间戳。我们可以使用这些时间戳来计算加载时长、解析时间、重定向时间、DNS查询时间等网页加载过程中的各项性能指标。[4]
2. Performance Resource Timing是Performance Timing API的扩展，它提供了对资源加载时间的更精确的度量，包括文件的DNS解析时间、TCP连接时间和服务器响应时间等。我们可以使用这些数据来优化网站性能，例如通过减少某些资源的大小或延迟加载以改善页面加载时间。[3]

The performance interface is a part of the High Resolution Time API. 

基于 Date 的时间精确到毫秒。但是，高分辨率时间可以精确到毫秒的分数。这非常精确，更适合用于准确测量时间。

值得注意的是，由用户代理（UA）测量的高分辨率时间不会随系统时间的任何更改而改变，因为它来自 UA 创建的全局、单调递增的时钟。时间始终在增加，无法强制减少。这对于时间测量是一个有用的约束条件。

在性能 API 中测量的每个时间都是一个高分辨率时间。这不仅使它成为测量性能的超级精确的方式，而且也是它成为高分辨率时间 API 的一部分以及我们经常看到两者一起提到的原因。

# Node vs 浏览器环境下的 performance api 有什么区别
node performance api : https://nodejs.org/api/perf_hooks.html
how to use per hooks in node : https://dev.to/bearer/measuring-performance-in-node-js-with-performance-hooks-585p

Node.js是一个服务端JavaScript环境，使用Chrome的V8引擎来运行JavaScript代码。与浏览器不同，Node.js没有DOM(Document Object Model)或BOM(Browser Object Model)，因为它并不关心文档或用户界面。相对的，在Node.js中，它提供了一些内置模块，如文件系统、网络、加密等等，这些能力帮助我们在服务器端处理数据或服务请求。

因此，Node.js中的Performance API和浏览器环境下的Performance API略有不同。在浏览器中，Performance API提供了Web应用程序性能信息的接口，例如页面加载时间、资源加载时间等。而在Node.js中，Performance API主要用于收集应用程序的指标，例如事件循环时间、CPU利用率等，以便开发人员可以优化应用程序的性能。

另外，Node.js还提供了一些专门用于性能分析的工具，例如在控制台输出的CPU分析器和堆分析器。这些工具可以帮助我们更深入地了解应用程序的性能瓶颈，并找到优化方案。

# JS 长任务有什么负面影响？
https://blog.clickio.com/how-long-javascript-tasks-affect-site-performance-and-what-to-do-about-it/

the user notices an increased load on the browser. In this case, clicks on page elements are delayed, scrolling becomes jerky, or the page does not respond at all.

Also, in addition to the site code (execution of JS), the formation of long tasks can be influenced by network speed and processing power. 

The FID metric (First Input Delay or waiting time before the first interaction with content) is the most affected by long tasks.

FID指标也会有影响，

https://web.dev/i18n/zh/long-tasks-devtools/

长任务是指长时间独占主线程，导致界面卡顿的 JavaScript 代码。

在加载网页时，长任务会占用主线程并使页面对用户输入无响应，即使它看起来已准备就绪。点击和轻按通常不起作用，因为尚未附加事件侦听器、单击处理程序等。

由于耗时超过 50 毫秒的复杂工作，会出现占用大量 CPU 的长任务。为什么是 50 毫秒？ RAIL 模型建议您在50 毫秒内处理用户输入事件，以确保在 100 毫秒内做出可见响应。如果你不这样做，操作和反应之间的连接就会中断。

# 白屏时间
https://css-tricks.com/paint-timing-api/

# 需要衡量的重要指标

https://web.dev/metrics/
Time to First Byte 第一字节时间 (TTFB)
First Contentful Paint 首次内容绘制 (FCP)
Largest Contentful Paint 最大内容绘制 (LCP)
First Input Delay 首次输入延迟 (FID)
Time to Interactive 可交互时间 (TTI)
Total Blocking Time 总阻塞时间 (TBT)
Cumulative Layout Shift 累积布局偏移 (CLS)
Interaction to Next Paint (INP)

# 怎么获取到页面每一个资源 or 接口的耗时呢？

1. 请求前后做mark
2. 通过监听resourse, responseEnd - requestStart

# 重排是什么，重绘是什么
重排（Reflow）指的是浏览器重新生成布局，重新排列元素的过程。当页面发生元素的位置、尺寸、内容等方面的变化时，浏览器需要重新计算元素的大小和位置，并重新布局和绘制页面，这个过程就是重排。

重排的代价很大，会消耗大量的CPU资源，导致网页性能下降。因此，在进行DOM或样式变更时，尽量减少重排是十分重要的。具体措施包括将多次dom or 样式变更合并成一次操作、避免查询DOM太过频繁、使用CSS动画代替JavaScript动画、使用CSS transform代替改变top/left属性等。

重绘（Repaint）指的是浏览器重新绘制页面上的元素，但不涉及到元素位置、尺寸等方面的变化。当页面发生颜色、背景、文本等方面的变化时，浏览器需要重新绘制这些元素，这个过程就是重绘。可以参考[1]。

与重排相比，重绘的代价更小，因为它只需要重新绘制页面上的元素，而不需要重新计算元素的大小和位置。但是，重绘也会消耗一定的CPU资源，所以尽量减少不必要的重绘是网页性能优化的一个方向。可以通过使用CSS的will-change属性、缓存图片等方式减少不必要的重绘。

1. CPU资源消耗：重排过程中，浏览器需要重新计算元素的大小和位置，并重新布局和绘制页面，这会消耗大量的CPU资源。
2. 用户体验：重排会导致页面卡顿、滚动不流畅等不良用户体验，影响网页质量和用户满意度。
3. 渲染性能：重排会导致渲染性能下降，因为重新绘制整个页面需要消耗更多的时间和资源。

# 假如必须做一些 dom or 样式变更，怎么尽量减少重排带来的性能损耗
将多次dom or 样式变更合并成一次操作：多个重排操作会导致浏览器多次计算和布局页面，合并操作可以减少重排次数。

避免查询DOM太过频繁：通过缓存元素、使用事件代理等方式可以避免多次查询DOM而引起的多次重排。

使用CSS动画代替JavaScript动画：CSS动画依赖于GPU，渲染速度更快。

使用CSS transform 代替改变top/left属性等：因为改变top/left属性需要重新计算元素的位置和大小，而使用CSS transform只需要修改元素的矩阵，不用重新计算位置和大小，不会引起重排。

使用虚拟 DOM 技术：通过对比新旧虚拟 DOM，只对有变化的节点执行 DOM 操作，减少了不必要的 DOM 操作并有效地避免了频繁的重排。

# http

## HTTP 缓存有什么规则？

HTTP缓存有以下规则：

1. 强缓存：浏览器在向服务器发送请求前，会先查看本地的缓存是否存在可用的缓存资源。如果存在，且资源未过期（过期时间根据Cache-Control和Expires字段指定），则直接从缓存中取出资源并使用，不再向服务器发送请求。强缓存优先级高于协商缓存。

2. 协商缓存：如果缓存资源已经过期或不存在，则向服务器发送请求。服务器在响应头中添加Last-Modified和Etag两个字段，浏览器将这些字段值和之前请求中保存的值进行比对，如果都没有发生变化，则提示浏览器可以使用缓存，否则返回服务器的最新数据。Etag的优先级高于Last-Modified。
HTTP缓存可复用性很高，有助于提高网页性能，减轻服务器负担。应用程序可以设置缓存策略来控制缓存行为，比如设置Cache-Control、Expires、Pragma等HTTP头部字段。

## HTTP缓存相关的头部字段有：

https://juejin.cn/post/6844903564679053325
https://www.keycdn.com/blog/http-cache-headers
https://www.holisticseo.digital/pagespeed/cache-control/
Cache-Control：用于控制缓存行为，比如max-age（指定缓存过期时间）、no-cache（强制每次向服务器验证缓存）等。

ETag：标识缓存资源的版本号，服务器通过比对ETag值来判断资源是否有更新。

Expires：指定缓存过期时间，是一个HTTP日期格式的时间戳。

Last-Modified：指示资源的最后修改时间，若资源被修改，则Last-Modified随之改变。

If-Modified-Since：和Last-Modified配合使用，客户端发送请求时添加该字段来告知服务器缓存资源的最后修改时间，服务器若发现资源未修改，则返回304 Not Modified。

If-None-Match：和ETag配合使用，客户端发送请求时添加该字段来告知服务器缓存资源的版本号，服务器若发现版本未更新，则返回304 Not Modified。

Vary：用于控制不同客户端或者代理缓存资源的策略，如Vary: User-Agent，表示根据浏览器的类型来缓存资源。

## http 数量多 vs 少的实际效果

请求的数量多会导致网页的加载速度变慢。因为每个请求都需要发送一个独立的HTTP请求，包括DNS解析、建立TCP连接、发送HTTP请求、接收响应等多个步骤，这些步骤都会消耗时间。如果请求的数量很多，就会导致这些步骤的时间相加较长，从而使页面加载速度变慢。
HTTP请求中的数量多与少在实际效果上有以下几个方面的差异：

响应速度：当HTTP请求数量较多时，每个请求都需要建立连接、传输数据、断开连接等过程，这样就会降低服务器的响应速度，导致网页的加载速度变慢。

网络带宽：当HTTP请求数量较多时，会占用更多的网络带宽资源，从而影响用户对其他网络应用的使用。

服务器压力：当HTTP请求数量过多时，会增加服务器的负载压力，如果服务器不能满足高并发的请求需求，就会导致系统宕机、崩溃等问题。

因此，为了提高网站的性能，一般采用优化HTTP请求的方式，如合并、压缩、缓存等技术，尽可能减少HTTP请求数量，提高网站的响应速度和用户体验。

## 如果我要请求10000条数据，是做两次请求去并发请求好，还是只做一次请求对浏览器的性能好

在请求10000条数据的情况下，将请求拆分为两个并发请求会大幅提高页面的加载速度，因为浏览器可以同时处理并发请求，而不需要等待一个请求完成后才能去处理另一个请求。这样可以显著减小页面的加载时间，提高用户体验。

但是，如果将所有数据都请求到浏览器端进行处理，则可能会增加浏览器的负担，导致页面出现卡顿、响应缓慢等问题，尤其是在低配置的设备上可能会更加明显。

综上所述，对于请求10000条数据的情况，一般来说将请求拆分为多个并发请求是更好的选择，可以优化页面加载速度和用户体验。但具体的方案需要根据实际情况进行调整和优化。

# 优化

## 压缩代码和文件

减少文件的大小：压缩代码和文件可以减少文件的大小，从而减小下载和传输的时间。尤其是对于网页加载来说，采用压缩方式可以减少页面的大小，从而加快页面加载速度。

减少网络带宽：压缩可以减小数据传输的大小，从而减少网络带宽的使用量，降低网络传输成本。特别是对于移动设备等带宽有限的场景来说，采用压缩方式可以大幅减少数据传输的大小，提高用户体验。

减少服务器负担：压缩可以减小文件的大小，从而减少服务器传输的数据量，降低服务器的负担。这样可以使服务器能处理更多的请求，提高应用程序的响应速度和并发能力。

如何压缩
JavaScript中压缩文件和代码的方法可以使用专门的压缩工具或库，例如 UglifyJS、Terser、Closure Compiler 等等。这些工具在压缩 JavaScript 代码时可以实现语法分析、语义理解和优化，从而减小文件大小、提高性能。压缩后的 js 文件可以在网页上加载更快，提高用户体验。
http://www.1zh.tech/hello-webpack/content/optimize/decrease-frontend-size.html

## 减少HTTP请求

减少 HTTP 请求是优化浏览器性能的一种常见方法，通过减少请求的数量可以提高网页的加载速度并降低网页的响应时间。在用户访问网页时，浏览器需要从服务器下载相关的 HTML、CSS、JavaScript、图片等资源，每一个资源都需要发起一次 HTTP 请求，并且每次请求都需要经过网络传输，经过解析等多个步骤才能得到最终结果，这些步骤都会耗费客户端和服务器的资源。如果网页中存在大量的资源，那么就会产生过多的 HTTP 请求，进而导致浏览器响应变慢，用户体验下降。

因此，减少 HTTP 请求的数量可以大大提高网页的性能和用户体验。具体做法可以包括以下几种方式：

删除不必要的图像、CSS 文件、JavaScript 文件等无用资源。

合并多个资源文件为一个文件，减少 HTTP 请求数量。

将小的图片合成一张大图使用 CSS Sprites 技术，减少 HTTP 请求次数。

使用浏览器缓存来减少重复的 HTTP 请求。

##  使用CDN

减少服务器负载：CDN 可以将网站的资源缓存在离用户更近的 CDN 节点上，当用户访问网站时，可以直接从最近的 CDN 节点获取资源，而不必每次都向服务器请求数据，从而减轻了服务器的负载。

加速资源传输：CDN 通常使用多个节点来分布地面覆盖全球，当用户请求网站资源时，CDN 会选择与用户最近的节点来提供服务，从而缩短了资源传输路径和时间，大大加快了资源的加载速度，提升了用户体验。

防止网络拥塞：当用户访问量剧增时，服务器可能会因为处理请求过多而崩溃，这时候 CDN 可以缓存部分请求，避免服务器瘫痪，保证网站的稳定性。

综上所述，使用 CDN 可以优化网站的性能，提高资源的加载速度，降低服务器负载，提升用户体验。参考资料：[1], [2]。

----

要使用 CDN（内容分发网络），可以按照以下步骤进行：

注册 CDN 服务商并购买 CDN 服务。

添加需要加速的域名或资源。在 CDN 服务商的控制面板中，添加需要加速的域名或资源，并设置相应的加速规则。

将域名解析到 CDN 服务商提供的 CNAME。

配置 CDN 加速。根据实际需求，配置 CDN 缓存策略、协议类型、SSL 等。

测试 CDN 加速效果。

需要注意的是，使用 CDN 服务需要一定的费用支出，并需确保 CDN 服务商的可靠性和安全性。

此外，不同的 CDN 服务商提供的具体操作步骤可能会有所差异，建议详细参考相应的官方文档和操作指南。

综上所述，要使用 CDN 可以购买 CDN 服务，添加需要加速的域名或资源，将域名解析到 CDN 服务商提供的 CNAME，配置 CDN 加速，并进行测试。

## 减少DOM操作,减少重绘和回流

减少DOM操作能优化性能，主要是因为DOM操作会引起浏览器的回流和重绘，从而消耗大量的计算资源和时间。当DOM结构较为复杂，DOM元素数量较多时，这种影响会更加显著。

而使用伪元素、阴影实现的内容，可以避免引入新的DOM元素，从而减少DOM操作；按需加载可以减少不必要的渲染；结构合理、语义化标签可以让DOM结构更为简洁明了。

比如对于大量DOM时的优化，可以使用文中提到的“批量操作”和“缓存”的方法，避免对DOM进行过多的读取和写入操作，从而提升性能。而虚拟DOM则是将DOM结构转换为JavaScript对象，通过比较前后两个JavaScript对象的差异，最终只对有变化的部分进行真正的DOM操作，避免了大量的无效操作，进一步提高了性能。


## 使用缓存
使用缓存可以优化性能，因为缓存可以将数据保存在内存中，下次需要使用该数据时可以直接从缓存中读取，而无需再次查询数据库或执行复杂的计算操作。这样可以大大提高数据访问的速度和效率，减少系统的负载压力，并且可以降低系统的响应时间，提升用户体验。在高并发的场景下，适当地使用缓存可以显著降低数据库的访问量，避免数据库的崩溃或性能下降，在一定程度上保证系统的稳定性和可靠性。

同时，在缓存的使用过程中，还需要注意缓存的失效策略和缓存的更新机制。合理设置缓存的生命周期可以避免过期数据的影响，而及时更新缓存可以确保数据的实时性和准确性。因此，使用缓存能优化性能是因为它有效地减少了系统的计算和IO开销，提高了数据的访问速度和效率，从而提升了系统的性能和吞吐量

1. 减少网络请求：浏览器在加载一个网页时需要请求服务器获取各种资源，如HTML、CSS、JavaScript、图像等。如果这些资源已经被缓存，则浏览器可以直接从缓存中获取资源，而无需再次向服务器发送请求，从而减少网络传输和延迟时间。
2. 减少服务器负载：当浏览器使用缓存时，服务器不再需要为每个请求提供资源，从而减少服务器的负载。这可以减少服务器的响应时间，提高网站的可用性和可靠性。
3. 减少页面加载时间：使用缓存可以减少页面加载时间，从而提高用户体验和满意度。当浏览器从缓存中获取资源时，资源可以快速加载并显示，而无需等待服务器响应，从而使页面加载更快。
4. 减少带宽成本：使用缓存可以减少带宽成本，因为缓存可以减少网络传输的数据量。如果每个用户都需要下载相同的资源，那么使用缓存可以避免多次下载相同的资源，从而减少带宽成本。

使用缓存是一种优化性能的有效方式，可以减少数据访问的延迟时间。以下是几种使用缓存来优化性能的方法：

1. 页面缓存：对于网站中的静态页面，可以使用页面缓存来提高访问速度。当用户请求一个页面时，服务器将页面的内容存储在缓存中，下一次用户请求相同的页面时，服务器可以直接从缓存中读取页面，而无需重新生成页面。这可以显著减少页面加载时间和服务器负载。

   页面缓存是一种将静态页面的内容存储在缓存中的技术，可以显著减少页面加载时间和服务器负载。以下是实现页面缓存的几种方法：

   1. HTTP缓存：HTTP缓存是一种浏览器缓存技术，可以将页面内容存储在浏览器缓存中。当用户请求页面时，浏览器可以直接从缓存中读取页面内容，而无需向服务器发送请求。为了启用HTTP缓存，可以在HTTP响应头中设置相关的缓存控制标头，如Cache-Control、Expires、Last-Modified等。
   2. 服务器端缓存：服务器端缓存是一种将页面内容存储在服务器内存或磁盘缓存中的技术。当用户请求页面时，服务器可以直接从缓存中读取页面内容，而无需重新生成页面。为了启用服务器端缓存，可以使用诸如memcached、Redis等缓存服务器来存储页面内容，并使用相关的缓存插件或库来实现缓存逻辑。
   3. 静态化页面：静态化页面是一种将动态页面转换为静态页面的技术。当用户请求页面时，服务器可以直接返回静态页面，而无需重新生成动态页面。为了实现页面静态化，可以使用静态页面生成器、页面缓存插件或自定义脚本来生成静态页面，并将其存储在服务器或CDN缓存中。

2. 数据库查询缓存：对于频繁查询的数据，可以使用数据库查询缓存来提高性能。当一个查询被执行时，查询结果将被缓存，下一次相同的查询将直接从缓存中获取结果，而不必再次执行查询。这可以减少数据库查询时间和服务器负载。

   1. 应用层缓存：将查询结果缓存到应用程序中，当下一次查询相同条件时，直接从缓存中获取结果，而不需要再次查询数据库。这种方式可以使用一些内存缓存库实现，如Redis、Memcached等。需要注意的是，缓存的有效期和一致性问题，可以通过设置缓存过期时间和定时刷新缓存等方式来解决。
   2. 数据库查询缓存：MySQL等一些数据库支持查询缓存功能。当一个查询请求到来时，数据库会先检查查询语句是否已经被缓存，如果已经被缓存，则直接返回缓存结果。这种方式可以有效地降低数据库的查询负载和响应时间。需要注意的是，查询缓存机制会占用一定的内存和CPU资源，缓存的一致性和失效问题也需要考虑。
   3. 数据库层面的缓存：一些NoSQL数据库，如Redis、MongoDB等支持缓存功能，可以将一些热点数据或结果缓存到内存中，以提高查询性能。这种方式需要注意缓存的一致性和可靠性，避免数据不一致或缓存数据丢失等问题导致业务异常。

3. 对象缓存：对于经常访问的对象（如用户会话、配置文件等），可以使用对象缓存来提高性能。当对象被访问时，它的内容将被存储在缓存中，下一次访问相同的对象时，可以直接从缓存中获取对象，而无需再次从磁盘或数据库中读取对象。

   实现对象缓存的一般步骤如下：

   1. 确定缓存需求：需要根据业务需求，确定哪些对象需要进行缓存，缓存的有效期是多久，以及缓存容量的大小等。
   2. 选择缓存框架：根据业务需求和技术栈，选择一个适合的缓存框架，比如Memcached、Redis、Ehcache等。
   3. 编写缓存逻辑：通过缓存框架提供的API，编写对象缓存的逻辑代码，包括对象的存储、读取和删除等操作。
   4. 对象序列化：需要将对象序列化为字节流或字符串格式，以便存储到缓存中。一般可以使用Java内置的序列化方式或第三方序列化库，如FastJSON、Protobuf等。
   5. 缓存更新机制：需要考虑缓存更新机制，即当缓存中的对象被修改或删除时，如何及时更新缓存。一般可以通过触发器、消息队列、定时任务等方式来实现缓存更新。
   6. 缓存清理策略：需要制定缓存清理策略，当缓存容量达到阈值或缓存过期时，如何清理缓存，以避免缓存占用过多内存空间。一般可以使用LRU（最近最少使用）或LFU（最少使用）等算法来选择清理缓存。
   7. 测试缓存效果：实现对象缓存后，需要进行测试，以确保缓存能够提高数据访问速度和减少服务器负载。可以使用性能测试工具，如JMeter、Gatling等，模拟大量请求并观察缓存命中率和响应时间等指标。

   需要注意的是，对象缓存只适用于一些较小的数据对象，如配置信息、用户信息等，对于大量数据的缓存，应该使用分布式缓存技术，如Memcached、Redis等，以提高缓存容量和性能。同时，在使用对象缓存时，需要注意缓存的一致性和可靠性，避免因缓存不一致或缓存数据丢失等问题导致业务异常。

4. CDN缓存：对于大型文件（如图像、视频等），可以使用CDN（内容分发网络）缓存来提高性能。CDN将文件存储在多个服务器上，当用户请求文件时，CDN会自动选择离用户最近的服务器提供文件。这可以显著减少文件下载时间和服务器负载。

   CDN（内容分发网络）缓存是一种将静态资源缓存到CDN边缘节点的技术，以提高资源加载速度和减少服务器负载。以下是进行CDN缓存的一些步骤：

   1. 注册CDN服务：首先需要注册CDN服务，例如阿里云CDN、腾讯云CDN等。注册成功后，可以得到一个CDN域名，用于访问静态资源。
   2. 配置CDN加速：将CDN域名与源站（即存储静态资源的服务器）进行关联，以便CDN服务器能够缓存静态资源。通常，CDN服务提供商会提供一些工具或插件，可以帮助用户进行CDN配置。
   3. 缓存策略配置：为了实现CDN缓存，需要对缓存策略进行配置，包括缓存过期时间、缓存控制标头、缓存区域等。缓存过期时间决定了CDN缓存多长时间，过期后需要从源站重新获取资源。缓存控制标头包括Cache-Control、Expires、Last-Modified等，用于控制缓存行为。缓存区域可以指定哪些地区的CDN节点需要缓存静态资源。
   4. 静态资源上传：将需要缓存的静态资源上传到CDN服务器，通常可以使用FTP、HTTP等协议进行上传。
   5. 测试CDN缓存：完成CDN配置后，可以进行测试，以确保CDN缓存生效。可以使用浏览器控制台、curl、httpie等工具来检查缓存状态和响应头信息。

5. 前端缓存：对于静态资源（如CSS、JavaScript等），可以使用前端缓存来提高性能。当用户访问网站时，静态资源将被存储在浏览器缓存中，下一次访问相同的网站时，浏览器可以直接从缓存中获取静态资源，而无需再次下载。这可以减少页面加载时间和服务器负载。

   1. 浏览器缓存：浏览器可以缓存静态资源，如CSS、JavaScript、图片等。在访问页面时，如果资源已经被缓存，则浏览器会直接从缓存中加载，而不是重新下载。可以通过设置HTTP响应头的Cache-Control和Expires字段来控制缓存的有效期和更新策略。
   2. Service Worker缓存：Service Worker是一种在浏览器后台运行的脚本，可以拦截和处理网络请求。可以通过Service Worker来实现离线缓存和动态缓存等功能，提高Web应用的访问速度和可用性。
   3. Web Storage缓存：Web Storage是一种客户端存储机制，包括localStorage和sessionStorage。可以使用localStorage来存储一些持久化的数据，如用户偏好设置、登录信息等；而使用sessionStorage来存储一些临时的数据，如表单数据、浏览历史等。需要注意的是，Web Storage的存储容量有限，一般在5~10MB之间。
   4. IndexedDB缓存：IndexedDB是一种客户端数据库，可以存储大量结构化数据。可以将一些数据缓存到IndexedDB中，以便在离线情况下访问。需要注意的是，IndexedDB的使用复杂度较高，需要编写复杂的异步代码。
   5. CDN缓存：可以通过将静态资源存储在CDN上，以实现全球分布式缓存。CDN可以根据用户的地理位置，自动选择最近的节点来响应请求，提高资源的访问速度和可用性。

## 异步加载

异步加载可以优化网页性能，因为异步加载允许浏览器在下载 JavaScript 时同时进行后续页面处理，从而提高页面的响应速度。在异步加载中，DOM 不会因为 JavaScript 加载而暂停渲染，这使得页面快速呈现给用户，增强了用户体验。在网页中，JavaScript 通常是网络请求中最耗时的部分，因此异步加载能够显著地提高页面的加载速度和响应速度。与之相对的，同步加载会阻止浏览器的后续处理，从而导致页面加载缓慢，用户体验不佳。

同时，异步加载也有利于并行下载，因为浏览器可以同时从多个源下载 JavaScript 文件，从而加快页面的加载速度。而同步加载只能从一个源下载文件，无法实现并行下载。

要实现异步加载以优化浏览器性能，可以通过以下几种方式：

采用 defer 和 async 属性：defer 属性用于延迟脚本执行，等待页面解析完毕后再执行；async 属性用于异步加载脚本，不会阻塞页面渲染。

动态加载 JavaScript：将 JavaScript 动态添加到 DOM 中，可以使其在需要时才被加载和执行。这种方式可以提高网页的加载速度，因为脚本文件只会在需要时才会被下载和执行。

使用 AJAX 技术：使用 AJAX 技术可以通过异步请求数据，而无需重新加载整个页面。这可以大大减少服务器负载，并提高页面响应速度。同时，也可以动态地更新页面内容，增强用户交互性。

优化图片加载：对于图片等资源的加载，可以利用懒加载、预加载和分步加载等技术进行优化。其中懒加载是指在用户滚动到内容区域时再加载图片，而预加载是指在页面加载时就开始加载图片，以提前准备好资源。分步加载则是指按照内容级别分批加载资源，以提高页面加载速度。

## 图片优化（懒加载、预加载和分步加载）
懒加载：也称为延迟加载，在用户需要访问图片或其他资源时才进行加载，而不是在页面刚加载时就全部加载完。这样可以大大减少页面的加载量和请求次数，提高页面的响应速度和性能。实现懒加载可以使用一些通用的库，如 jQuery Lazyload，或根据具体需求进行编写。


预加载：在页面初始化时就开始加载未呈现的资源，以便用户在需要时能够快速访问。与懒加载相反，预加载可以使得整个页面的资源都在较短时间内加载完成，从而快速呈现给用户。常用的实现方式包括使用 link 标签的 preload 属性、动态创建 img 和 script 标签等。

<!-- 分步加载：将页面内容按照优先级进行分类，优先加载用户当前最需要的关键内容，再进行后续内容的加载。这样可以使用户快速看到重要信息，快速建立对页面的理解和信任感，提高使用效率和满意度。 -->

### 如何实现懒加载

使用 Intersection Observer API：该 API 可以监测元素是否进入了视口（即可视区域），当元素出现在视口中时才会触发加载事件，从而实现懒加载。这种方法需要浏览器支持 Intersection Observer API。

使用 getBoundingClientRect() 方法：该方法可以获取元素相对于视口的位置和大小信息，通过判断元素是否进入可视区域来触发加载事件。这种方法需要动态计算元素与视口的位置和大小，并且如果有多个元素需要进行懒加载时，代码较为复杂。

使用 jQuery Lazyload 等库：这类库提供了封装好的懒加载功能，只需配置一些参数即可实现，如图片加载时的占位符等。

### 如何实现预加载

预加载是一种优化网页性能的方式，它可以提前请求需要的资源并缓存到本地，以便在后面需要使用时能够快速加载。以下是实现预加载的一些方法：

使用 <link> 标签的 preload 属性：这是 HTML5 标准引入的一种方式，可以在 <link> 标签中通过设置 rel="preload" 来实现预加载。例如，可以在页面头部添加如下代码预加载一个 CSS 文件：

```js
<link rel="preload" href="example.css" as="style">
```

使用 JavaScript 动态创建 <link> 标签预加载资源：通过 JavaScript 动态创建 <link> 标签来实现预加载，在需要的时候将资源添加到页面中。例如，下面的代码可以预加载一个图片：

```js
var img = new Image();
img.src = "example.jpg";
```

使用 Webpack 等打包工具进行预加载：Webpack 可以通过 import() 和 require.ensure() 方法实现按需加载和预加载。例如，下面的代码可以预加载一个组件：

`import(/* webpackPrefetch: true */ './example.js');`

<!-- ### 如何实现分步加载 -->


## 节流防抖

因为在一些需要响应用户操作的场景中，比如滚动条滚动、搜索框输入等，如果直接绑定事件处理函数，事件触发频率很高，就会导致大量的计算和渲染操作，从而降低前端性能。这时候，采用节流（throttle）和防抖（debounce）的技术可以避免重复触发事件，从而减少频繁的计算和渲染，提高性能。

节流和防抖的原理分别是将多次触发事件的执行函数变成只执行一次或者每隔一定时间执行一次。在使用防抖的情况下，当用户在搜索框中连续输入的时候，只有当用户停止输入一段时间之后，才会触发一次搜索事件，避免了频繁的请求操作，提高了性能。同理，在使用节流的情况下，当用户连续滚动页面时，只有每隔一定时间才会触发一次滚动事件，避免了重复的计算和页面渲染操作，提高了性能。

✅把昨天的基础理论知识内容填写到feishu上
✅整理这几天的笔记，把feishu上的笔记优化一下

✅把performance api 的学习问题重复验证，并写demo

[ ] 填写feishu的学习时间线

[ ] 把feishu上最近的文档的问题都作回复
