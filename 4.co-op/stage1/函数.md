> 函数是一组有组织的、可重用的代码，用于执行单个相关操作。默认情况下，所有函数都返回一个值。

## a. 参数

> 函数参数是指在函数定义时声明的变量，用于接收函数调用时传入的值。函数参数的作用是让函数更加灵活和通用，可以接受不同的输入，并根据输入来执行不同的操作。

### 1. 函数参数类型

- 参数值类型

> 函数的参数是不具有类型限制的

1. 基本数据类型：包括字符串、数字、布尔值和 undefined。
2. 对象类型：包括对象、数组、函数、日期、正则表达式等。
3. null：虽然 null 是一个对象类型，但是在 JavaScript 中被认为是一个独立的基本数据类型。
4. Symbol：这是在 ES6 中引入的一种新的数据类型，它表示唯一的、不可变的值。

需要注意的是，在 JavaScript 中，函数的参数是不具有类型限制的，即使你在定义函数时指定了参数的类型，但实际上仍然可以传入其他类型的值。因此，在使用函数参数时，需要自行处理参数类型的问题，以确保函数的正确性和可靠性。

- 形参，实参

在调用函数时，可以传递实参来给形参赋值。如果函数有多个参数，实参之间用逗号分隔。

### 2. 传值 vs 传引用

1. 传值（by value）：将原始数据类型（例如字符串、数字、布尔值等）作为参数传递给函数时，函数会创建一个新的变量来存储传入的值，并将该变量传递给函数。在函数内部对该变量的修改不会影响到原始变量的值。
2. 传引用（by reference）：将对象类型（例如数组、对象、函数等）作为参数传递给函数时，实际上传递的是该对象在内存中的引用地址，函数参数和原始参数引用的是同一个对象，因此在函数内部对该对象的修改会影响到原始对象的值。

```JavaScript
function changeProperty(obj) {
  obj.prop = 'new value';
}

let myObj = { prop: 'old value' };
console.log(myObj.prop); // 输出 old value
changeProperty(myObj);
console.log(myObj.prop); // 输出 new value
```

### 3. 函数参数的默认值

> 函数参数的默认值是指在函数定义时，为参数指定一个默认值，这样在函数调用时如果没有传入该参数，就会使用该默认值。

#### a. 如何设置默认值

（解构设置默认值）

1. “默认值赋值”（default value assignment）

```JavaScript
function myFunc(param1 = defaultValue1, param2 = defaultValue2) {
  // 函数体
}
```

2. 使用解构赋值和默认值赋值

```js
function greet({ name = 'World', greeting = 'Hello' } = {}) {
  console.log(`${greeting}, ${name}!`);
}
```

#### b. 默认值和 undefined 的区别

如果使用默认值的参数在函数调用时传递了一个 undefined 值，则该参数将使用默认值而不是 undefined 值。这是默认值和 undefined 的区别。传入undefined可以作为一个占位使用，如果某个参数不需要传的时候，可以传递undefined。

```JavaScript
function myFunc(param1 = 'default value') {
  console.log(param1);
}

myFunc(); // 输出 'default value'
myFunc(undefined); // 输出 'default value'
myFunc(null); // 输出 null
myFunc('other value'); // 输出 'other value'
```

### 4. 可变参数(不定参数)

不定参数（也称为可变参数）指在函数定义时不确定参数数量，使用 rest 参数将所有参数收集为一个数组。在函数体内使用该数组进行处理。

需要注意的是，不定参数必须是函数的最后一个参数。如果将其放在函数定义中的其他参数之前，那么在调用函数时，这些参数将被视为 undefined。因此，rest 参数应该始终放在函数定义中的最后一个参数位置。

```JavaScript
function myFunc(...args) {
  console.log(args);
}

myFunc(); // 输出 []
myFunc(1, 2, 3); // 输出 [1, 2, 3]
myFunc('a', 'b', 'c'); // 输出 ['a', 'b', 'c']
```

#### rest 参数

rest 参数是指在函数定义中使用三个点 `...` 语法来表示可以接收任意数量的参数，并将这些参数存储在一个数组中。rest 参数必须作为最后一个参数出现，因为它会将函数中剩余的参数收集到一个数组中。

```JavaScript
function myFunc(a, b, ...rest) {
  console.log(a, b, rest);
}

myFunc(1, 2, 3, 4, 5); // 输出 1, 2, [3, 4, 5]
```

#### spread 参数

如果希望将数组中的每个元素作为单独的参数进行传递，则可以使用扩展运算符（...）来展开数组

```JavaScript
function myFunc(a, b, c) {
  console.log(a, b, c);
}

const arr = [1, 2, 3];
myFunc(...arr); // 输出 1, 2, 3
```

#### rest 和 argument 的区别

1. rest 参数是一个真正的数组，而 arguments 对象只是一个类数组对象。
2. rest 参数只包含传递给函数的实际参数，而 arguments 对象包含所有传递给函数的参数，包括函数定义时声明的参数和调用时传递的参数。
3. rest 参数可以使用 ES6 的数组方法进行处理，例如 forEach、map、filter 等，而 arguments 对象不支持这些数组方法，需要先将其转换为数组才能使用。

```JavaScript
function myFunc(...rest) {
  console.log(rest);
  console.log(arguments);
}

myFunc(1, 2, 3, 4); // 输出 [1, 2, 3, 4] 和 { '0': 1, '1': 2, '2': 3, '3': 4 }
```

### 5. 函数参数的解构

函数参数的解构是指在函数定义时使用对象解构或数组解构来获取函数参数中的某些值。通过解构，可以将需要的值从对象或数组中提取出来，使代码更加简洁易懂。

#### 使用对象解构

在函数定义时，可以使用对象解构来获取函数参数中的某些值

```JavaScript
function myFunc({ name, age }) {
  console.log(`My name is ${name}, and I'm ${age} years old.`);
}

const person = { name: 'Alice', age: 20 };
myFunc(person); // 输出 "My name is Alice, and I'm 20 years old."
```

在上面的例子中，函数 myFunc 接收一个对象作为参数，并使用对象解构来获取 name 和 age 属性的值。在调用函数时，传递了一个包含 name 和 age 属性的对象作为参数。

#### 如何使用数组解构

在函数定义时，也可以使用数组解构来获取函数参数中的某些值，例如：

```JavaScript
function myFunc([first, second]) {
  console.log(`The first item is ${first}, and the second item is ${second}.`);
}

const arr = ['apple', 'orange', 'banana'];
myFunc(arr); // 输出 "The first item is apple, and the second item is orange."
```

在上面的例子中，函数 myFunc 接收一个数组作为参数，并使用数组解构来获取第一个和第二个元素的值。在调用函数时，传递了一个包含多个元素的数组作为参数。

#### 如何在函数参数中使用解构

除了在函数定义时使用解构来获取参数值之外，在函数调用时也可以使用解构来传递参数值，例如：

```JavaScript
function myFunc({ name, age }) {
  console.log(`My name is ${name}, and I'm ${age} years old.`);
}

const person = { name: 'Bob', age: 30 };
myFunc(person); // 输出 "My name is Bob, and I'm 30 years old."

// 使用解构来传递参数值
myFunc({ name: 'Alice', age: 20 }); // 输出 "My name is Alice, and I'm 20 years old."
```

在上面的例子中，在第一次调用函数时，传递了一个包含 name 和 age 属性的对象作为参数。在第二次调用函数时，使用对象解构和对象字面量的方式传递参数值。

需要注意的是，在使用解构时，如果参数对象中不存在解构所需的属性，那么对应的变量将被赋值为 undefined。如果需要给变量设置默认值，可以使用解构赋值的方式，例如：

```JavaScript
function myFunc({ name = 'unknown', age = 0 }) {
  console.log(`My name is ${name}, and I'm ${age} years old.`);
}

const person1 = { name: 'Bob' };
myFunc(person1); // 输出 "My name is Bob, and I'm 0 years old."

const person2 = { age: 30 };
myFunc(person2); // 输出 "My name is unknown, and I'm 30 years old."
```

### 6. 箭头函数的参数

- 在箭头函数中，如果只有一个参数，可以省略参数括号；如果有多个参数，则需要使用括号
- 如果参数需要默认值，则可以使用 ES6 中的默认参数语法。
- 箭头函数的参数没有自己的 arguments 对象。如果需要访问函数的参数，可以使用 rest 参数语法。

```JavaScript
 const func = (...args) => {
  console.log(args);
}

func(1, 2, 3); // 输出 [1, 2, 3]
```

### 7. 参数顺序

- 参数的顺序可能会影响函数的行为

- 如果函数参数有固定的顺序，但是中间的参数不想传递，可以通过在需要跳过的参数位置上使用 undefined 来实现。

- 如果不传递任何值或者传递 null 等 falsy 值时，函数会将该参数解释为缺失参数，而不是跳过该参数。因此，为了明确地跳过某个中间参数，需要显式地将其设置为 undefined。

可以考虑使用对象参数的方式，将参数封装为一个对象，这样你就可以只传递需要的参数，而不需要按照固定顺序传递所有参数。

```JavaScript
function greet({ message = "Hello", name = "World", age = null } = {}) {
  console.log(message + " " + name);
  if (age) {
    console.log("You are " + age + " years old.");
  }
}
// 使用 "= {}" 的默认参数值是为了确保当没有传入参数时，options 参数被解构时不会出现 undefined 错误。
greet(); // 输出 "Hello World"
greet({ name: "Tom" }); // 输出 "Hello Tom"
greet({ message: "Hi", name: "Alice" }); // 输出 "Hi Alice"
greet({ name: "Bob", age: 20 }); // 输出 "Hello Bob" 和 "You are 20 years old."
```

### 8. 通过参数创建函数（柯里化）

> 在 JavaScript 中，可以使用柯里化（currying）技术来通过参数创建函数。柯里化是一种将函数转换为接受一系列参数的函数序列的技术，每个序列中的函数只接受单个参数。

> 更通俗的讲法是，柯里化是将多元函数简化为一元函数

```JavaScript
function add(a, b) {
  return a + b;
}

function curryAdd(a) {
  return function(b) {
    return a + b;
  };
}

const add1 = curryAdd(1);
console.log(add1(2)); // 输出 3
console.log(add1(3)); // 输出 4
```

在 React 中，柯里化可以应用于很多场景，以下是几个常见的使用场景：

1. 高阶组件（Higher-Order Component，HOC）：HOC 是一个函数，它接受一个组件作为参数，并返回一个增强后的组件。HOC 可以用来实现一些横切关注点（cross-cutting concerns），例如日志、权限控制等。柯里化可以帮助我们将 HOC 的参数和返回值分别作为柯里化函数的前后两个参数，这样可以使 HOC 更加清晰和易于组合。
2. 函数式组件：函数式组件是一个只接受 props 参数并返回 React 元素的函数。柯里化可以用来将函数式组件转换为接受其他参数的函数，例如接受样式和事件处理函数等参数。这样可以使函数式组件更具通用性和可复用性。
3. 钩子函数（Hooks）：钩子函数是 React 16.8 引入的一种新的组件状态管理方式，它允许我们在函数式组件中使用状态和其他 React 特性。柯里化可以用来将钩子函数的参数分解为多个参数，这样可以使钩子函数更加清晰和易于测试。
4. 命名参数：React 组件的 props 是一个包含多个属性的对象，柯里化可以用来将这些属性拆分为多个参数，这样可以使组件的调用更具有可读性和可维护性。

## b. 返回值

JavaScript 函数的返回值是指在函数执行完毕后返回给调用者的值。函数可以返回任何 JavaScript 数据类型，包括数字、字符串、对象、数组和布尔值等。

函数的返回值通常通过 `return` 语句指定。如果函数没有指定 `return` 语句，则默认返回 `undefined` 值。

`return` 语句会立即结束函数的执行，并返回指定的值，因此函数中 `return` 语句后面的代码不会被执行。

```JavaScript
// 函数也可以返回一个对象或数组等复杂数据类型
function getPerson() {
  return {
    name: 'John',
    age: 30,
    gender: 'male'
  };
}

var person = getPerson(); 
```

## c. 闭包

> 闭包是指在一个函数内部定义的函数，它可以访问到该函数的私有变量以及在该函数作用域之外定义的变量。
>
> 闭包（Closure）是指函数和函数内部能访问到的变量（即自由变量）的组合。在JavaScript中，函数嵌套函数的情况非常常见，如果内部函数能够访问外部函数的变量，即使外部函数执行完毕，内部函数依然能够访问到这些变量，这种情况就称为闭包。

```JavaScript
function outer() {
  var count = 0;
  function inner() {
    count++;
    console.log(count);
  }
  return inner;
}

var increment = outer();
increment(); // 输出1
increment(); // 输出2
increment(); // 输出3
```

闭包只能取得包含函数中任何变量最后一个值，保存的是整个变量对象，不是某个特殊变量。

```JavaScript
// 只会返回10，即使是遍历函数，最终结果是10，不会返回各自不同的索引值
function createFunctions(){
  var result = new Array();
  for (var i=0; i < 10; i++){
    result[i] = function(){
      return i;
    };
  }
  return result; 
} 

//强制返回各自不同的索引值
function createFunctions(){
  var result = new Array();
  for (var i=0; i < 10; i++){
    result[i] = function(num){
      return function(){
        return num;
      };
    }(i);
  }
  return result;
}
```

闭包常见的应用包括：

1. 模块化开发：通过闭包来实现类似于私有变量的效果，防止变量被外部访问和修改。
2. 防抖和节流：通过闭包来实现防抖和节流等函数式编程的方法，提高程序的性能。
3. 实现回调函数：通过闭包来实现回调函数，可以让函数在异步执行时能够访问到原始的数据和环境。

在使用闭包时，需要注意以下几点：

1. 内存泄漏：由于闭包会保留外部函数的变量引用，如果不正确地使用闭包，可能会导致内存泄漏。因此，当闭包不再使用时，应该及时释放相关资源。

2. 变量共享：由于闭包可以访问外部函数的变量，因此多个闭包可能会共享同一个变量，这可能会导致不可预期的结果。为了避免这种情况，应该尽量避免使用全局变量，并在使用闭包时注意变量的作用域。闭包导致函数依赖函数外的状态，可能导致函数变得不够纯

   ```js
   function createMultiplier(factor) {
     return function(num) {
       return num * factor;
     }
   }
   
   const double = createMultiplier(2);
   console.log(double(3)); // 输出 6
   
   const triple = createMultiplier(3);
   console.log(triple(3)); // 输出 9
   
   const quadruple = createMultiplier(4);
   console.log(quadruple(3)); // 输出 12
   
   factor = 5;
   console.log(double(3)); // 输出 6，而不是 15
   
   ```

   `createMultiplier` 函数返回了一个闭包 `multiplier`，这个闭包可以访问外部的变量 `factor`。在执行 `double(3)` 的时候，`factor` 变量被设置为 2，并且返回 6。当执行 `triple(3)` 的时候，`factor` 变量被设置为 3，并且返回 9。

   但是，如果在执行 `factor = 5` 之后再次调用 `double(3)`，返回的值仍然是 6，而不是 15。这是因为 `multiplier` 函数依赖于外部变量 `factor` 的状态，而不是函数的输入参数。因此，当外部变量 `factor` 被修改时，会影响到函数 `multiplier` 的行为，导致函数的不纯。这种不纯的行为可能会导致代码难以理解、维护和调试。

3. 性能问题：由于闭包会保留外部函数的变量引用，因此它的创建和销毁过程比普通函数要复杂。如果在循环中频繁使用闭包，可能会导致性能问题。为了避免这种情况，应该尽量避免在循环中使用闭包，并在需要使用时，尽量使用函数式编程的方法，如防抖、节流等。

4. 变量命名冲突：由于闭包可以访问外部函数的变量，因此在使用闭包时，应该避免变量命名冲突。为了避免这种情况，可以使用模块化编程的方法，将变量封装在模块内部，避免变量名冲突。

## d. 作用域

#### 作用域的基础知识

##### 什么是作用域？

作用域是指程序中定义变量的可访问范围。在JavaScript中，作用域由执行上下文和作用域链组成。执行上下文是指当前执行代码的环境，而作用域链是指在当前执行上下文中，可以访问的变量的链式结构。

##### 作用域链是什么

它由当前执行上下文的变量对象和其外部环境的变量对象构成。当代码在当前执行上下文中查找变量时，如果在当前的变量对象中找不到变量，就会在外部环境的变量对象中继续查找，直到找到该变量或者查找到全局对象。

##### 全局作用域和局部作用域

全局作用域是指在代码的任何地方都可以访问的变量，它定义在全局对象中。而局部作用域是指在特定的代码块或函数中定义的变量，只能在该代码块或函数内部访问。

在JavaScript中，每个函数都会创建一个新的局部作用域，而全局作用域则是整个程序的顶层作用域。通过合理的使用作用域和作用域链，可以避免变量名冲突，提高程序的可读性和可维护性。

#### 作用域链和执行上下文

##### 执行上下文是什么

执行上下文是 JavaScript 中用于管理代码执行的一种内部数据结构。每当 JavaScript 引擎执行一段代码时，都会创建一个执行上下文来存储该代码的相关信息，如变量、函数声明、作用域链等。执行上下文是 JavaScript 实现作用域和闭包的关键。

执行上下文是最外围的执行环境，宿主不同，表示的执行环境的对象也不一样。web中，global context是windows object,When an execution context has executed all of its code, it is destroyed销毁, taking with it all of the variables and functions defined within it

内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。

当代码在一个环境中执行时候，会创建变量对象的一个作用域链。作用域链的作用，保证对执行环境有权访问的所有变量和函数的有序访问。

##### 创建执行上下文的过程

1. 创建变量对象（Variable Object，VO）：变量对象是执行上下文中的一个重要概念，它用于存储该上下文中定义的变量、函数声明等信息。对于全局执行上下文来说，变量对象就是全局对象（Window），对于函数执行上下文来说，变量对象则包括了函数的参数、函数声明和内部声明的变量。
2. 建立作用域链（Scope Chain）：作用域链是用于解析标识符（变量名、函数名等）的一种机制，它由当前执行上下文的变量对象和所有外层执行上下文的变量对象组成，形成一个链式结构。当代码在当前执行上下文中访问一个变量时，JavaScript引擎会先查找当前执行上下文的变量对象，如果没找到，则在作用域链中查找。
3. 确定this指向：this指向在执行上下文创建时确定，它的值取决于函数调用方式。

##### 执行上下文栈

执行上下文栈（Execution Context Stack）是用于管理执行上下文的一种数据结构，也称为调用栈（Call Stack）。JavaScript引擎在执行代码时，会将每个执行上下文压入执行上下文栈中，当一个执行上下文执行完毕后，它会从执行上下文栈中弹出，控制权回到上一个执行上下文。

##### 作用域链的形成过程

1. 执行上下文在创建时会将当前变量对象添加到作用域链的最前端，这样当前执行上下文就可以访问到自己的变量。
2. 当代码在当前执行上下文中访问一个变量时，JavaScript引擎会先查找当前执行上下文的变量对象，如果没找到，则在作用域链中查找。作用域链的查找方向是由当前执行上下文的作用域链决定的，也就是说作用域链中靠前的变量对象拥有更高的优先级。如果在整个作用域链中都没找到该变量，则认为该变量未定义。

#### 词法作用域和动态作用域

词法作用域（Lexical Scope）和动态作用域（Dynamic Scope）是两种不同的作用域规则，它们决定了变量的可见范围和访问顺序。

词法作用域指的是作用域在代码编写时就已经确定好了，在代码的词法分析阶段就已经确定了，即在代码块中声明的变量的作用域在代码块内部。这种作用域是静态的，也就是说它的作用域范围在代码运行之前就已经确定好了。

动态作用域指的是作用域在程序运行时才能确定，它是根据函数调用栈来确定的，即当前正在执行的函数的作用域。这种作用域是动态的，也就是说它的作用域范围是随着程序运行时变化的。

JavaScript使用词法作用域。在JavaScript中，函数作用域是词法作用域，变量的作用域在函数定义时就已经确定好了，无论在何处调用函数，都会在函数内部找到相应的变量。这种作用域使得代码的行为更加可预测和易于理解。

#### ES6中的作用域

##### 块级作用域

S6中的作用域和之前的JavaScript版本中的作用域是相同的，都是基于词法作用域的。

但是，ES6中引入了块级作用域。在ES6之前，JavaScript中只有全局作用域和函数作用域，而没有块级作用域。块级作用域指的是在代码块内部定义的变量只在该块内部有效，超出该块范围就失效了。

##### const / let / var作用域的区别

ES6引入了两个新的关键字来声明块级作用域的变量：let和const。使用let或const声明的变量只在当前代码块内部有效，不会污染外部的作用域。在同一作用域中可以重复声明同名的let变量，但不可以重复声明同名的const变量。变量提升的部分也会不同。

##### arrow function的作用域

ES6中也引入了箭头函数，箭头函数与普通函数不同，它没有自己的this和arguments，它的this和外层函数的this是相同的。这种特殊的函数作用域也被称为词法作用域。

普通函数也是词法作用域。词法作用域指的是变量的作用域由它在代码中声明的位置所决定，与函数被调用的方式无关。在 JavaScript 中，函数的作用域是在函数声明时确定的，而不是在函数调用时确定的。因此，在函数内部声明的变量只能在函数内部访问，除非通过函数的返回值将变量传递到函数外部。

箭头函数的特殊之处在于它的 this 值是词法上绑定的，也就是说，箭头函数的 this 值由外层作用域中的 this 值决定，而不是由函数被调用时的上下文决定。

##### 模板字面量中的作用域

模板字面量（Template literals）是 ES6 引入的一种字符串表达方式，可以使用反引号 `` 包裹字符串，并且支持在字符串中使用变量、表达式等语法。

在模板字面量中，变量和表达式可以通过 `${}` 语法嵌入到字符串中。这些变量和表达式的作用域和普通的 JavaScript 变量和表达式的作用域一样，都是在当前的代码块中。

举个例子：

```JavaScript
let name = "Tom";
console.log(`Hello, ${name}!`);
```

在这个例子中，模板字面量的作用域就是当前的代码块，也就是全局作用域。因为 `name` 变量是在全局作用域中定义的，所以在模板字面量中可以直接使用。

如果在模板字面量中使用的变量或表达式是在某个函数中定义的，那么它们的作用域就是这个函数的作用域。例如：

```JavaScript
function sayHello(name) {
  console.log(`Hello, ${name}!`);
}

sayHello("Tom");
```

在这个例子中，模板字面量 `${name}` 中的 `name` 变量就是在 `sayHello` 函数中定义的，因此它的作用域就是 `sayHello` 函数的作用域。

## e. 递归与尾递归

### 递归

> 递归是指一个函数在其定义中调用自身的过程。

#### 递归的基本原理

基本原理是将问题分解为更小的子问题，直到问题变得足够小，可以通过简单的方式来解决。这样做可以使代码更简洁，易于理解。

- 递归必须包含一个基本情况，这个基本情况通常是指递归到一定程度时不再需要递归。
- 递归算法通常包含两个部分：基本情况和递归情况。

```JavaScript
   // 阶乘
   // n! = n * (n-1) * (n-2) * ... * 2 * 1
   function factorial(n) {
     if (n === 0) {   // base case
       return 1;
     } else {
       return n * factorial(n - 1);   // recursive case
     }
   }
   
   factorial(5);   // returns 120
```

在上面的例子中，函数 `factorial` 是递归函数。当传入值为0时，函数将返回1，这是递归的基本结束条件，也称为“基本情况”（base case）。

否则，它将通过调用自己来计算 `(n-1)` 的阶乘，并将结果乘以`n`。 这是递归的“递归情况”（recursive case）。

```JavaScript
   // 斐波那契数列
   function fibonacci(n) {
     if (n < 2) { // base case
       return n;
     } else {
       return fibonacci(n-1) + fibonacci(n-2); // recursive case
     }
   }
   
   console.log(fibonacci(6)); // Output: 8
```

#### 实现递归算法的方法

   -  递归函数的定义和调用。
   - 使用条件判断语句来判断递归结束的条件。
   - 确定递归函数的参数和返回值类型。
   - 使用递归函数来处理递归情况。

#### 递归的优缺点

   - 优点：递归能够简化问题的处理，使代码更加简洁、易读。
   - 缺点：递归调用会产生额外的函数调用开销，可能导致栈溢出等问题。

#### 递归应用场景

   - 树形结构的操作：树形结构是递归的典型例子。许多操作，如遍历、搜索、插入和删除等，都可以使用递归来实现。
   - 排列组合问题：对于一些排列组合的问题，例如汉诺塔问题、n皇后问题等，递归是一种有效的求解方法。
   - 分治算法：分治算法也是递归的一种应用。在分治算法中，原问题被划分为若干个规模较小的子问题，然后递归地解决每个子问题，并将解合并成原问题的解。
   - 动态规划：动态规划问题通常可以通过递归算法来解决。在动态规划中，问题通常被分解为若干个子问题，然后递归地解决每个子问题，并将解合并成原问题的解。
   - 数学计算：递归在数学计算中也有广泛的应用。例如，计算阶乘、斐波那契数列等都可以使用递归来实现。

#### 如何避免递归问题

   - 尝试使用循环来代替递归。某些递归问题可以通过循环解决，因为循环不涉及函数调用和栈操作，所以通常比递归更高效并且不会产生栈溢出的风险。
   - 对于必须使用递归的问题，可以考虑使用尾递归。尾递归是指递归函数的最后一步是调用自身，这样就可以避免在调用子函数之前积累大量的栈帧。许多编程语言都支持尾递归优化，包括Scheme和Erlang等函数式编程语言。
   - 增加栈空间的大小。如果无法避免使用递归，并且递归深度较大，则可以通过增加栈空间的大小来避免栈溢出。许多编程语言都支持向递归函数传递额外参数以控制栈大小，例如Python的sys.setrecursionlimit()函数可以设置递归深度的上限。
   - 优化递归算法。有些递归算法可以进行优化，例如记忆化搜索、分治等技巧，以减少递归深度和计算量。

#### 递归的注意事项

   - 递归的边界条件：递归必须有一个边界条件，当满足该条件时，递归终止。如果没有边界条件或者边界条件不正确，递归将会无限进行，导致栈溢出。
   - 递归的递推公式：递归必须有一个递推公式，该公式描述了如何将一个问题分解成子问题。如果递推公式不正确，递归可能会产生无限循环或者结果不正确。
   - 递归的性能问题：递归可能导致栈溢出或者效率低下。因此，在使用递归时，应该考虑使用尾递归或迭代实现，避免过多的栈空间消耗和函数调用开销。
   - 递归的调试问题：递归代码通常比较难以调试，因为它会产生多层嵌套的函数调用。可以使用打印或者调试工具等方式，对递归进行调试。
   - 递归的可读性问题：递归可能导致代码变得比较复杂，因为它涉及到多层嵌套的函数调用。可以通过给函数命名、添加注释、使用尾递归等方式，提高代码的可读性。

### 尾递归

尾递归是指在函数的最后一步中调用自身，并且返回值是该函数的返回值。尾递归可以被优化为迭代，从而减少函数调用时的内存消耗和栈溢出的风险。在 JavaScript 中，尾递归可以使用 ES6 的严格模式（strict mode）来实现。

#### 1. 什么是尾递归？

##### a. 尾递归的定义及其特点

尾递归是指一个函数在执行的最后一步调用自身，并且该调用的返回值直接被当前函数所返回。也就是说，函数调用发生在当前函数的尾部（最后一行代码），因此称为尾递归。尾递归和普通的递归不同，普通递归会在递归调用结束之后还需要进行一些操作，而尾递归的递归调用是整个函数的最后一步，不存在后续操作。

尾递归的特点是可以被优化为迭代循环，从而减少函数调用时的内存消耗和栈溢出的风险，因为在优化后，尾递归的调用会被替换为循环，从而避免了不必要的函数调用栈的生成。

1. 最后一步是对自身的调用：尾递归函数在执行的最后一步中调用自身，并且没有其他操作。
2. 函数调用不会增加栈的大小：尾递归的调用会被优化为迭代，从而减少函数调用时的内存消耗和栈溢出的风险。
3. 返回值是递归调用的返回值：尾递归函数的返回值是最后一次递归调用的返回值，不需要对递归调用的返回值进行其他操作。

（牺牲时间换空间，牺牲空间换时间）

```JavaScript
// 这个函数在执行时会产生多次递归调用，每次调用都会在栈中占用一定的内存空间。由于递归的缺陷，当 n 很大的时候，函数的性能会急剧下降，甚至可能导致栈溢出。
function fibonacci(n) {
  if (n <= 1) {
    return n;
  } else {
    return fibonacci(n - 1) + fibonacci(n - 2);
  }
}

// tail recursion
function fibonacci(n, a = 0, b = 1) {
  if (n === 0) return a;
  if (n === 1) return b;
  return fibonacci(n - 1, b, a + b);
}

function fibonacci(n, a = 1, b = 1) {
  if (n <= 1) {
    return b;
  } else {
    return fibonacci(n - 1, b, a + b);
  }
}

// 这个函数使用了尾递归的方式来计算斐波那契数列。由于尾递归的特点是函数调用时不需要额外的栈空间，因此可以避免栈溢出的问题，并且在性能上比递归更优秀。在这个函数中，我们使用了两个参数 a 和 b 来保存当前的斐波那契数列的值，然后在下一次函数调用时将它们更新为下一个斐波那契数列的值。
```

1. 如果 n 的值小于等于 1，函数直接返回 b 的值，因为斐波那契数列的第一项和第二项都为 1。
2. 如果 n 的值大于 1，则调用 fibonacci 函数，并将参数 n-1、b 和 a+b 传入函数中。此时，函数的最后一步操作为调用自身，并且返回值为函数的返回值，因此可以使用尾递归进行优化。
3. 在递归调用中，a 和 b 的值分别为斐波那契数列中当前项的前两项，a + b 的值为当前项，因此可以保证每次调用时，都是在计算下一个斐波那契数。
4. 当递归调用结束后，函数返回最后一项的值。

##### b. 尾递归的优势和劣势

#### 2. 尾递归与递归的区别

##### 递归的定义及其特点

递归是指一个函数调用自身的过程。在递归中，函数会将一个问题拆分为更小的子问题，直到达到某个结束条件，然后逐层返回结果。递归函数一般有两个重要的组成部分：基本情况和递归情况。基本情况指的是递归结束的条件，递归情况指的是函数调用自身来解决更小的子问题。

递归的特点包括：

- 简洁：使用递归可以简化一些算法和代码实现，使得代码更加易读和易懂。
- 灵活：递归可以解决很多问题，特别是在处理树形结构、链表等数据结构时，递归的效果尤为明显。
- 可读性强：递归能够清晰地表达问题的解法，提高代码可读性。

##### 递归和尾递归的区别和联系

递归和尾递归都是函数调用自身的过程，但是它们在实现方式和效率上有所不同。

1. 区别：

（1）递归是指一个函数在执行过程中调用了自身，但不是所有的递归都是尾递归。在普通递归中，函数的最后一步操作是调用自身之外的操作，会在调用栈中堆积多层调用，占用大量内存。而在尾递归中，函数的最后一步操作是调用自身，相当于循环，每次调用都会覆盖上一次调用的栈帧，不会堆积多层调用。

（2）尾递归的特点是在函数返回时调用自身，且返回值为函数的返回值，这样可以避免在调用栈中堆积多层调用，减少内存消耗和运行时间。

1. 联系：

（1）尾递归是一种特殊的递归，它们都是函数自身调用自身，具有相同的语法形式。

（2）尾递归可以转化为循环来实现，而循环也可以转化为尾递归来实现。

（3）递归和尾递归都可以实现相同的功能

#### 3. 尾递归的实现方式

##### a. 使用 ES6 的严格模式实现尾递归

要使用 ES6 的严格模式实现尾递归，需要确保函数满足以下几个条件：

1. 函数必须是一个纯函数，即不依赖外部变量或状态，只接受参数并返回结果。
2. 函数的最后一步操作必须是对自身的调用，并将其结果作为返回值，确保没有其他操作会修改返回结果。
3. 在调用自身前，所有的变量都已经被计算出来，不再需要再次访问它们。这可以通过将所有变量都作为参数传递给函数来实现。

```JavaScript
// 阶乘函数的尾递归
'use strict';

function factorial(n, acc = 1) {
  if (n <= 1) return acc;
  return factorial(n - 1, n * acc);
}

console.log(factorial(5)); // 输出 120
```

在这个示例中，函数 `factorial` 接收两个参数。第一个参数 `n` 表示要计算阶乘的数，第二个参数 `acc` 表示当前已经计算出的阶乘结果。如果 `n` 小于等于 1，那么函数直接返回当前的阶乘结果；否则，它会继续调用自身，将 `n-1` 和 `n*acc` 作为新的参数传递进去。

这个函数利用了 ES6 中的默认参数语法，将 `acc` 参数设置为初始值 1。这样，在第一次调用时，不需要额外传递任何参数。因此，这个函数可以像普通的函数一样调用，而不需要使用特殊的方式来处理尾递归。

通过这种方式，我们可以避免创建不必要的调用帧，从而避免堆栈溢出。

##### b. 尾递归的转化为迭代的实现方式

尾递归函数可以通过迭代的方式来实现，这样可以避免由于递归调用而导致的栈溢出问题。

```JavaScript
function factorial(n) {
  let acc = 1;
  for (let i = n; i > 0; i--) {
    acc *= i;
  }
  return acc;
}

console.log(factorial(5)); // 120
```

在这个示例中，我们使用 `for` 循环来迭代求解阶乘。在每次循环中，我们将 `i` 的值乘以累积值 `acc`，然后将结果存储回 `acc` 中。当循环结束后，我们返回结果。

需要注意的是，通过迭代实现尾递归可以避免函数调用栈溢出的问题，因为我们不再创建新的函数执行上下文。此外，迭代通常比递归更快，因为它们避免了创建和销毁大量的函数执行上下文。

#### 4. 尾递归优化的方法和技巧

1. 循环/迭代函数代替递归

将递归调用转换为循环，这样可以避免调用栈溢出的问题。具体实现方式是使用一个循环来模拟递归调用的过程，并在每次循环迭代中更新参数，直到满足退出条件。

1. 使用尾递归消除器

尾递归消除器是一个工具，可以自动将尾递归函数转换为等效的非递归形式，从而避免调用栈溢出的问题。该工具可以根据语言规范中的尾递归优化规则进行转换，同时还可以进行一些额外的代码优化操作。

1. 使用尾递归优化编译器

一些编程语言的编译器已经内置了尾递归优化功能，例如Erlang、Scheme等函数式编程语言。这些编译器能够自动将尾递归函数转换为迭代形式，从而避免调用栈溢出的问题。如果使用这些语言编写代码，可以直接调用编译器进行尾递归优化，不需要手动处理代码。

#### 5. 尾递归的应用场景

1. 数字运算等

a) 数学计算

对于一些数学计算问题，通常可以使用递归算法进行求解。例如，计算斐波那契数列、阶乘等问题都可以使用递归算法。由于这些问题的输入规模较大，可能会导致递归调用的深度也很大，此时可以使用尾递归优化来避免栈溢出的问题。

b) 数据结构处理

一些数据结构的操作也可以使用递归算法进行实现，例如二叉树的遍历、图的遍历等。由于这些数据结构的深度也很大，可能会导致递归调用的深度也很大，此时可以使用尾递归优化来提高代码性能和可靠性。

c) 状态机

状态机是一种常用的计算模型，用于描述系统在不同状态之间的转换关系。状态机的实现通常利用递归算法来解析输入流，但是如果递归深度太大，也会出现栈溢出的问题。此时可以使用尾递归优化来消除栈空间的使用。

尾递归在一些递归深度比较大的问题中具有重要的应用价值，可以提高代码的性能和可靠性。

1. 在函数式编程中的应用

- 高阶函数

在函数式编程中，高阶函数是一个非常重要的概念，它可以将函数作为参数或返回值来实现更加灵活的编程。高阶函数通常采用递归算法实现，如果递归深度比较大，就需要使用尾递归优化来避免栈溢出的问题。

- 函数组合

函数组合是函数式编程中另一个重要的概念，它可以将多个函数组合成一个新的函数来实现复杂的计算功能。函数组合通常也采用递归算法实现，因此也需要使用尾递归优化来提高代码性能和可靠性。

- 模式匹配

模式匹配是函数式编程中一种特殊的语法结构，用于匹配不同的数据类型并执行相应的操作。模式匹配通常也采用递归算法实现，因此也需要使用尾递归优化来避免栈溢出的问题。

- 列表处理

在函数式编程中，列表是一种非常常见的数据结构，经常用于存储和处理数据。列表的操作通常也采用递归算法实现，因此也需要使用尾递归优化来提高代码性能和可靠性。

#### 6. JavaScript 中的尾递归库和工具

- trampoline 和 thunk 函数
- Lodash 和 Ramda 等 JavaScript 库中的尾递归实现方式

## f. 普通函数、匿名函数、类函数、箭头函数

普通函数是指使用 `function` 关键字定义的一种函数。它可以接受参数，并且可以有返回值，可以在任何地方被调用。示例：

```JavaScript
function add(a, b) {
  return a + b;
}

console.log(add(2, 3)); // 输出 5
```

匿名函数是指没有函数名的函数，它通常是作为其他函数的参数传递，或者是赋值给一个变量。示例：

```JavaScript
const add = function(a, b) {
  return a + b;
};

console.log(add(2, 3)); // 输出 5
```

类函数是 ES6 引入的一种函数，它通过 `class` 关键字定义。类函数有一个构造函数和一些方法，可以用来创建对象。示例：

```JavaScript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHi() {
    console.log(`Hi, my name is ${this.name} and I'm ${this.age} years old.`);
  }
}

const john = new Person('John', 30);
john.sayHi(); // 输出 "Hi, my name is John and I'm 30 years old."
```

箭头函数是 ES6 引入的一种函数，它使用 `=>` 符号定义。箭头函数是匿名函数的一种特殊形式，它可以使用简洁的语法来定义函数，并且不需要使用 `function` 关键字。箭头函数没有自己的 `this`，它会使用定义时的 `this`。示例：

```JavaScript
const add = (a, b) => a + b;
console.log(add(2, 3)); // 输出 5

const person = {
  name: 'John',
  age: 30,
  sayHi: () => {
    console.log(`Hi, my name is ${this.name} and I'm ${this.age} years old.`);
  }
};

person.sayHi(); // 输出 "Hi, my name is undefined and I'm undefined years old."
```

总结：

- 普通函数、匿名函数和类函数是三种常见的函数定义方式，用于实现不同的功能。
- 箭头函数是一种匿名函数的特殊形式，它使用简洁的语法定义函数，并且没有自己的 `this`。

## g. this指向

`this` 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象。

JavaScript中的`this`关键字指的是当前执行上下文的上下文对象。它的指向是在函数被调用时动态绑定的，具体取决于函数的调用方式和上下文。以下是关于`this`指向的知识内容框架：

### `this`的指向方式

- 默认绑定：在函数中直接调用，指向全局对象（在浏览器中为`window`对象，在Node.js中为`global`对象）。
- 隐式绑定：函数作为对象的方法调用时，`this`指向调用该方法的对象。
- 显式绑定：通过`call`、`apply`或`bind`方法指定函数执行时的上下文。
- new绑定：当一个函数被使用`new`关键字调用时，`this`指向新创建的实例对象。
- 箭头函数中的`this`：箭头函数没有自己的`this`绑定，它的`this`是外层作用域中的`this`。
- 如果函数使用了严格模式（'use strict'），那么在该函数中的 this 将不会指向全局对象。
- 当函数作为事件处理函数时，this 指向触发事件的元素。

需要特别注意的是，在 JavaScript 中，this 的值是在函数被调用时才确定的，而不是在函数被定义时就确定的。因此，在使用 this 关键字时，需要注意当前代码执行的上下文环境以及 this 的具体指向。

### 全局函数/匿名函数的this

全局函数中this = window,函数被作为某个对象的方法调用时，this等于那个对象。匿名函数的执行环境具有全局性，其this通常指向windows

```JavaScript
let message = {
  name:'john',
  regularFunction: function(){
    console.log(this)
    console.log('hello' + this.name);
    //hello john
  },
  arrowFunction:()=>console.log('hi'+this.name)
  //hi
}

message.regularFunction();
message.arrowFunction();
cnosole.log(this.name)// empty string
cnosole.log(this) // window object
```

### 箭头函数的this

箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值。

箭头函数体内的 this 对象，就是定义该函数时所在的作用域指向的对象，而不是使用时所在的作用域指向的对象。

箭头函数的this对象是定义时所在的对象，而不是使用时所在的对象，所以指向的是the window

```JavaScript
var name = “The Window”;
var object = {
  name : “My Object”,
   //匿名函数
  getNameFunc : function(){
    return function(){
        //这个this指向全局，因为匿名函数的执行环境具有全局性，this.name会指向第一个出现的name
      return this.name;
    };
  } 
};
object.getNameFunc()() 
//”The Window” (in non-strict mode) 
```

在定义匿名函数之前，我们把对象赋值给了一个名叫`that`的变量，而在定义了闭包之后，闭包也可以访问这个变量，因为它是我们在包含函数中特意声明的一个变量，即使在函数返回之后，that也仍然引用着object,所以调用`object`,`getNameFunc()()`就返回了，`my object`.

```JavaScript
var name = “The Window”;
var object = {
  name : “My Object”,
  getNameFunc : function(){
    var that = this;
    return function(){
      return that.name;
    };
  } 
};
object.getNameFunc()()  //”My Object” 
```