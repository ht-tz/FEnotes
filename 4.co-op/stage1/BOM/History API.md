# History API

# 什么是History API？

History API 提供了访问浏览器会话历史记录的功能，通过全局对象 history。它暴露了有用的方法和属性，可以在用户的历史记录中前后导航，并操纵历史记录栈的内容。

History API 是浏览器提供的一组接口，用于操作浏览器的历史记录，包括向前或向后导航、添加或修改历史记录等。使用 History API 可以实现前端路由、单页应用等功能，可以提高页面的性能和用户体验。

# History API的基本用法

![img](https://raw.githubusercontent.com/linhaishe/blogImageBackup/main/history-api/history-20230409164701141.png)

| 方法/事件/属性                                  | 描述                                                         |
| ----------------------------------------------- | ------------------------------------------------------------ |
| `history.pushState(stateObject, title, URL)`    | 添加一条新的历史记录，同时修改 URL 和浏览器的地址栏，但不会刷新页面。该方法会触发 `popstate` 事件。 |
| `history.replaceState(stateObject, title, URL)` | 用指定的状态对象、标题和 URL 替换当前历史记录条目。该方法不会添加新条目到历史记录栈中，而是修改当前历史记录条目的内容和 URL。该方法也会触发 `popstate` 事件。 |
| `window.onpopstate` 事件                        | 当浏览器历史记录栈中的活动记录改变时，该事件将被触发。       |
| `history.back()`;`history.go(-1);`              | 将浏览器回退到上一个历史记录，相当于点击浏览器的后退按钮。   |
| `history.forward()`;`history.go(1);`            | 将浏览器前进到下一个历史记录，相当于点击浏览器的前进按钮。   |
| `history.go(0)`; `history.go();`                | refreshing the page                                          |
| `go(n)`                                         | 根据当前页面在历史记录中的位置，移动到相对位置为 `n` 的页面。 |
| `length`                                        | 表示历史记录中页面的数量。                                   |
| `state`                                         | 返回当前页面的状态对象，即最后一个 `pushState()` 或 `replaceState()` 的第一个参数。 |

`pushState` /`replaceState`方法的第一个参数 stateObj 是一个 JavaScript 对象，用于保存当前历史记录的状态信息。当用户通过浏览器的前进或后退按钮返回到该历史记录时，该对象会作为 popstate 事件的 state 属性传递给事件处理函数。事件的 state 属性包含历史记录条目的状态对象的副本。状态对象可以是任何可序列化的内容。因为 Firefox 会将状态对象保存到用户的磁盘上，以便在用户重新启动浏览器后可以恢复它们，所以我们对状态对象的序列化表示强制施加了 640k 字符的大小限制。如果您传递一个其序列化表示超过此限制的状态对象给 pushState()，该方法将抛出异常。

`title`一般不写了,but at the time of writing, every browser simply ignores it.

```js
window.addEventListener("popstate", function(event) {
  if (event.state && event.state.message) {
    const message = event.state.message;
      alert(message);
      }
  });
```

# History API与SEO

## History API与SEO

SEO（Search Engine Optimization，搜索引擎优化）是一种通过优化网站结构、内容和链接等方式，使得网站在搜索引擎中获得更好的排名，从而提高网站的流量和曝光度的技术。SEO 通常是为了让搜索引擎更好地理解网站的内容和结构，从而提高网站在搜索结果中的排名。

1. 使用 History API 可以实现前端路由，使得用户在操作网站时，不需要重新加载整个页面，而只需要更新部分内容。这种方式可以提高用户体验，但对于搜索引擎来说，可能会造成一些困扰，因为搜索引擎更习惯于通过 URL 来索引网页内容，而不是通过 JavaScript 来实现页面的更新。因此，如果使用了前端路由，需要采取一些措施来让搜索引擎更好地理解网站的内容和结构，比如使用动态 URL、添加页面标题和描述、使用 sitemap 等。
2. 如果网站使用了 History API 来更新页面内容，而没有合理地配置页面标题、描述等元信息，那么搜索引擎可能会难以理解网站的内容和结构，从而降低网站的排名和曝光度。因此，使用 History API 的网站需要特别注意页面的元信息的设置，以便让搜索引擎更好地理解网站的内容和结构。

# 使用History API的注意事项

## 安全问题

1. 避免将敏感信息存储在历史记录的状态对象中，因为这些信息可能会被保存到用户的磁盘上，从而导致信息泄露。
2. 避免使用历史记录来存储密码、令牌等敏感信息，因为这些信息可能会被其他网站访问到。
3. 避免使用 `replaceState()` 方法来模拟页面跳转，因为这样会使页面的跳转行为与用户预期不符，从而引起混淆和安全问题。
4. 避免使用 `history.go(-1)` 或 `history.back()` 方法来跳转到前一个页面，因为这样可能会使用户离开当前网站，从而降低用户体验和安全性。
5. 避免使用 `history.pushState()` 和 `history.replaceState()` 来改变页面的 URL，而不是使用服务器端重定向或者页面跳转，因为这样可能会使用户无法复制或分享页面 URL，从而降低网站的可用性。
6. 避免通过 JavaScript 改变页面的 URL 来欺骗用户，例如将一个恶意网站的 URL 伪装成另一个网站的 URL，从而引导用户访问恶意网站。
7. 在使用 pushState() 和 replaceState() 方法时，需要注意 URL 的格式和安全性

## 浏览器兼容性

1. 在 Safari 5.0 和 Chrome 5.0 以前的版本中，不支持状态对象的序列化和反序列化，因此在使用 `pushState()` 或 `replaceState()` 方法时，需要确保状态对象可以被序列化为字符串。
2. 在 Firefox 4.0 和 Chrome 5.0 以前的版本中，使用 `pushState()` 和 `replaceState()` 方法后，浏览器地址栏中的 URL 不会发生改变，需要使用其他技术来修改 URL。
3. 在 IE 10 以前的版本中，不支持 `pushState()` 和 `replaceState()` 方法，需要使用其他技术来实现历史记录的管理。
4. 在移动设备上，例如 iOS 和 Android，因为设备的资源有限，所以对历史记录的管理可能存在一些限制和差异，需要注意兼容性问题。
5. 对于不支持 History API 的浏览器，可以使用 hash 路由来模拟路由。

## 性能问题

1. 频繁调用 `pushState()` 和 `replaceState()` 方法可能会影响性能。因为每次调用这些方法都会创建一个新的历史记录条目，如果调用次数过多，会导致历史记录栈变得很大，占用大量内存，同时也会增加页面的加载和渲染时间。因此，应该尽量避免频繁调用这些方法，只在必要时使用。
2. 在使用状态对象时，需要注意对象的大小。因为状态对象需要被序列化和保存到本地存储中，如果对象过大，会增加序列化和反序列化的时间和内存消耗，超过640k会抛出异常。同时，状态对象也会被保存在本地存储中，如果保存的历史记录过多，也会占用大量的存储空间。因此，在使用状态对象时，应该尽量保持对象的简单和小巧。
3. 在监听历史记录变化时，需要注意监听器的数量和复杂度。因为每个监听器都会被触发，如果监听器数量过多，会增加页面的加载和渲染时间，同时也会增加 CPU 的负担。因此，在编写监听器时，应该尽量保持监听器数量的少和简单，只监听必要的事件。

# 示例应用

- 实现单页应用
- 实现浏览器历史记录管理

# 如何处理在浏览器中使用的 hash 和 history 模式

