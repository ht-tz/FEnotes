# 第一阶段-学习计划

# 阶段一：熟练掌握 JavaScript

时间定在 1 **个月**内完成；

Mentor：@陈凡 

## Roadmap

| Milestone        | Concept                                                      |
| ---------------- | ------------------------------------------------------------ |
| 函数 ✅           | 参数、返回值闭包作用域执行上下文(执行栈)递归普通函数、匿名函数、类函数、箭头函数`this` 指向 |
| 类型 ✅           | 值类型、引用类型、包装类型类型判断typeof/constructor/instanceof/...类型转换 |
| 熟悉常用类型 api | Date ✅<br />Array ✅<br />RegExp                              |
| 熟悉常见工具库   | Lodash<br />date-fns(or Moment, or dayJS)<br />Axios         |
| 熟悉 BOM API     | History API ✅<br />localstorage & sessionstorage & cookie & indexDB ✅<br /> Performance API ✅<br />WebSocket |
| 熟悉 DOM API ✅   | DOM Query 接口(querySelector、getElementByxxx)<br />DOM Maintenance<br />DOM Event Model<br />DocumentFragment |
| ES6+ ✅           | Promise & Generator & async-await<br />Fetch vs XHR<br />Proxy vs Reflect<br />Map vs Weakmap<br />Set vs WeakSet<br />模板字符串 |
| FP ✅             | Map & Reduce & forEach & pick filter & findflow & compose & curry |
| 基础原理 ✅       | 内存泄露现象、原因、排查方法 ✅<br />垃圾回收算法✅<br />引用计数✅<br />标记清除✅<br />事件循环原理(Node & Browser) ✅<br />JavaScript 解释执行过程 ✅ |
| 性能优化         | 事件委托<br />尾递归优化的逻辑与原理                         |
| 最佳实践         | 使用设计模式减少冗余代码<br />函数避免 Side Effect<br />异常监控 & 兜底 |

## 验收问题

1. Fetch vs XHR 接口，有什么区同点？什么情况下必须使用 XHR？
2. 事件委托是什么？为什么能优化性能？React 事件与事件委托之间是什么关系？
3. DOM 操作的成本是啥？为什么要尽量避免 DOM 操作？

## 实战项目

#### 实现千分位格式化

```JavaScript
const format = (num) => {};

format(100000) => "100,000"
format(100000.0001) => "100,000.0001"
format(100000000000000.0001) => "100,000,000,000,000.0001"
```

#### 实现斐波那契数列

> 注意性能

#### 实现防抖节流函数

#### 手动实现 instanceOf 的机制

#### 实现数组 `reduce/map` 方法

#### 实现数组去重方法

```JavaScript
const uniq = (arr) => {};

uniq([1, 2, 3, 1]) => [1, 2, 3]
uniq([1, 2, 3, {a:1}, {a:1}, 1]) => [1, 2, 3, {a:1}, {a:1}]
```

#### 实现嵌套数组打平算法

```JavaScript
flatten([1, [2, [3]]]) => [1, 2, 3]
```

#### 计算两个数组之间的交集：

```JavaScript
intersection([2, 1], [2, 3]) => [2]
```

#### 实现冒泡排序

> https://www.runoob.com/w3cnote/bubble-sort.html

#### 实现快速排序

> https://www.runoob.com/w3cnote/quick-sort-2.html

#### 判断一个数字是否为素数

#### 实现 LFU(Least frequently used，最少访问算法) 

根据访问缓存的历史频率删除最不常用的缓存数据。

# 阶段二：