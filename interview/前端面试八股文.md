# 零、html/css

1. 选择器优先级关系：

   内联样式 > ID 选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 标签选择器 = 伪元素选择器

2. 清除浮动的方法

   1. 后面不需要浮动的块元素。加clear：both;

   2. <mark>让父级触发BFC</mark>（Block Formatting Context-块级格式化上下文）效果BFC格式化成最开始的样式，标准文档流。使得其浮动元素会被父级计算高度，从而也就避免了高度塌陷。

      [Example](https://codepen.io/linhaishe/pen/VwPXQVz?editors=1000)

      [深入理解：overflow:hidden——溢出,坍塌,清除浮动](https://blog.csdn.net/Hukaihe/article/details/51298665)

      触发方式：

      ​            1、float:left
      ​            2、display:inline-block
      ​            3、overflow:hidden  溢出隐藏
      ​            4、position:absolute 定位

      3. <img src="/Users/chenruo/Library/Application Support/typora-user-images/image-20210906160312195.png" alt="image-20210906160312195" style="zoom:33%;" />

3. w3c盒模型和ie盒模型的区别？

    *IE盒模型*：width=border+padding+content---Borer-box

   W3C*盒模型*：width就等于内容区的width---content-box
   
4. 浅拷贝和深拷贝
   

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存。

5. promise是什么？

    Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。

6. 无论promise是成功还是失败都想执行操作该怎么做？

    <img src="/Users/chenruo/Library/Application Support/typora-user-images/image-20210906161736398.png" alt="image-20210906161736398" style="zoom:33%;" />

7. 两个promise想要同步执行的方法？（说两种及以上）

    https://blog.csdn.net/qq_24147051/article/details/92791998

    1. Promise.all
    2. promise.race
    3. promise.allsettled

8. 什么是Async和await？

    async 表示这是一个async函数， await只能用在async函数里面，不能单独使用

    async 返回的是一个Promise对象，await就是等待这个promise的返回结果后，再继续执行

    await 等待的是一个Promise对象，后面必须跟一个Promise对象，但是不必写then()，直接就可以得到返回值

# 一、JS

## 一、数据类型

### 1. JavaScript有哪些数据类型，它们的区别？

JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。 其中 Symbol 和 BigInt 是ES6 中新增的数据类型： 

un sos bnb
#### Symbol & BigInt
- Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。 

- BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。

#### 可分为原始数据类型和引用数据类型： 

- 栈：原始数据类型（Undefined、Null、Boolean、Number、String） 

- 堆：引用数据类型（对象、数组和函数）

### 2. 数据类型检测方式

#### a. typeof

Array , object , null typeof -> object

```js
console.log(typeof 2);               // number
console.log(typeof true);            // boolean
console.log(typeof 'str');           // string
console.log(typeof []);              // object    
console.log(typeof function(){});    // function
console.log(typeof {});              // object
console.log(typeof undefined);       // undefined
console.log(typeof null);            // object
```

#### b. instanceof

instanceof可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。

instanceof只能正确判断引用数据类型，而不能判断基本数据类型。instanceof 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。

```js
console.log(2 instanceof Number);                    // false
console.log(true instanceof Boolean);                // false 
console.log('str' instanceof String);                // false 

console.log([] instanceof Array);                    // true
console.log(function(){} instanceof Function);       // true
console.log({} instanceof Object);                   // true
```

#### c. constructor

constructor有两个作用，一是判断数据的类型，二是对象实例通过 constrcutor 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，constructor就不能用来判断数据类型了

```js
console.log((2).constructor === Number); // true
console.log((true).constructor === Boolean); // true
console.log(('str').constructor === String); // true
console.log(([]).constructor === Array); // true
console.log((function() {}).constructor === Function); // true
console.log(({}).constructor === Object); // true
```

```js
function Fn(){};
 
Fn.prototype = new Array();
 
var f = new Fn();
 
console.log(f.constructor===Fn);    // false
console.log(f.constructor===Array); // true
```

#### d. Object.prototype.toString.call()

Object.prototype.toString.call() 使用 Object 对象的原型方法 toString 来判断数据类型

```js
var a = Object.prototype.toString;
 
console.log(a.call(2));
console.log(a.call(true));
console.log(a.call('str'));
console.log(a.call([]));
console.log(a.call(function(){}));
console.log(a.call({}));
console.log(a.call(undefined));
console.log(a.call(null));
```

同样是检测对象obj调用toString方法，obj.toString()的结 果和Object.prototype. tostring.cal(obj)的结果不一
样，这是为什么?

这是因为toString是Object的原型方法，而Array、 function等 类型作为Object的实例，都重写了toString方法。
不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法(function类
型返回内容为函数体的字符串，Array类 型返回元素组成的字符串...)，

而不会去调用Object.上原型toString方法

(返回对象的具体类型)， 所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型;因此，在想要得到对象的具体类型时，应该调用Object原型.上的toString方法。

### 3. 检测数组的方式有哪些

```js
Object.prototype.toString.call(obj).slice(8,-1) === 'Array';
obj.__proto__ === Array.prototype;
Array.isArrray(obj);
obj instanceof Array
Array.prototype.isPrototypeOf(obj)
```

### 4. 检测对象的方式有哪些

```js
Object.prototype.toString.call({}) === 'Object';
obj instanceof object
console.log(({}).constructor === Object); // true
```

### 5. null和undefined区别

- 首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。 

- undefined 代表的含义是未定义，null 代表的含义是空对象。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。 

- undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。

- 当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。

### 6.🐒intanceof 操作符的实现原理及实现 

instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。

```js
function myInstanceof(left, right) {
  // 获取对象的原型
  let proto = Object.getPrototypeOf(left)
  // 获取构造函数的 prototype 对象
  let prototype = right.prototype; 
 
  // 判断构造函数的 prototype 对象是否在对象的原型链上
  while (true) {
    if (!proto) return false;
    if (proto === prototype) return true;
    // 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型
    proto = Object.getPrototypeOf(proto);
  }
}
```

### 7. 为什么0.1+0.2 ! == 0.3，如何让其相等（未完成）

### 8. 🐒如何获取安全的 undefined 值？ 

因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 `void ___ `没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。

### 9. typeof NaN 的结果是什么？ 

NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。

```js
typeof NaN; // "number"
```

NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x === x 不成立）的值。而 NaN !== NaN 为 true。

### 10. isNaN 和 Number.isNaN 函数的区别？ 

- 函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。 
- 函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。

```js
isNaN(1);
 Number.isNaN("123");
```



### 11. 🐒== 操作符的强制类型转换规则？ 

对于 == 来说，如果对比双方的类型不一样，就会进行类型转换。假如对比 x 和 y 是否相同，就会进行如下判断流程： 

1. 首先会判断两者类型是否相同，相同的话就比较两者的大小； 
2. 类型不相同的话，就会进行类型转换； 
3. 会先判断是否在对比 null 和 undefined，是的话就会返回 true 
4. 判断两者类型是否为 string 和 number，是的话就会将字符串转换为 number

```js
1 == '1'
      ↓
1 ==  1
```

5. 判断其中一方是否为 boolean，是的话就会把 boolean 转为 number 再进行判断

```js
'1' == true
        ↓
'1' ==  1
        ↓
 1  ==  1
```

6. 判断其中一方是否为 object 且另一方为 string、number 或者 symbol，是的话就会把 object 转为原始类型再进行判断

```js
'1' == { name: 'js' }
        ↓
'1' == '[object Object]'
```

![image](http://ww1.sinaimg.cn/large/005NUwyggy1gu01mn6mg6j60rx0bujsf02.jpg)

### 12. 🐒其他值到字符串的转换规则

1. Null 和 Undefined 类型 ，null 转换为 "null"，undefined 转换为 "undefined"， 
2. Boolean 类型，true 转换为 "true"，false 转换为 "false"。 
3. Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。
4.  Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。 
5. 对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如"[object Object]"。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。

### 13. 🐒其他值到数字值的转换规则

1. Null 类型的值转换为 0。 
2. Undefined 类型的值转换为 NaN。 
3. Boolean 类型的值，true 转换为 1，false 转换为 0。 
4. String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。 
5. Symbol 类型的值不能转换为数字，会报错。 
6. 对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。

为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。 如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。

### 14. 其他值到布尔类型的值的转换规则？ 

以下这些是假值： 

1. undefined 

2. null 

3. false 

4. +0、-0 和 NaN

5. ""

   假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。

### 15. || 和 && 操作符的返回值？ 

|| 和 && 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。 

- 对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。 
- && 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。

 || 和 && 返回它们其中一个操作数的值，而非条件判断的结果

### 16. Object.is() 与比较操作符 “===”、“==” 的区别？ 

● 使用双等号（==）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。 

● 使用三等号（===）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。 

● 使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。

### 17. 🐒<mark>什么是 JavaScript 中的包装类型？ </mark>

在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：

```
const a = "abc";
a.length; // 3
a.toUpperCase(); // "ABC"
```

在访问'abc'.length时，JavaScript 将'abc'在后台转换成String('abc')，然后再访问其length属性。 JavaScript也可以使用Object函数显式地将基本类型转换为包装类型：

```
var a = 'abc'
Object(a) // String {"abc"}
```

也可以使用valueOf方法将包装类型倒转成基本类型：

```
var a = 'abc'
var b = Object(a)
var c = b.valueOf() // 'abc'
```

```
var a = new Boolean( false );
if (!a) {
	console.log( "Oops" ); // never runs
}
```

### 18. JavaScript 中如何进行隐式类型转换？(未完成)

### 19. + 操作符什么时候用于字符串的拼接？ 

根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。 简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。 那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。

###  20. 为什么会有BigInt的提案？ 

JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。

### 21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别

1. 扩展运算符

```
let outObj = {
  inObj: {a: 1, b: 2}
}
let newObj = {...outObj}
newObj.inObj.a = 2
console.log(outObj) // {inObj: {a: 2, b: 2}}
```

2. Object.assign():

```js
let outObj = {
  inObj: {a: 1, b: 2}
}
let newObj = Object.assign({}, outObj)
newObj.inObj.a = 2
console.log(outObj) // {inObj: {a: 2, b: 2}}
```

可以看到，两者都是浅拷贝。 

● Object.assign()方法接收的第一个参数作为目标对象，后面的所有参数作为源对象。然后把所有的源对象合并到目标对象中。它会修改了一个对象，因此会触发 ES6 setter。 

● 扩展操作符（…）使用它时，数组或对象中的每一个值都会被拷贝到一个新的数组或对象中。它不复制继承的属性或类的属性，但是它会复制ES6的 symbols 属性。

### 22. 如何判断一个对象是空对象

- 使用JSON自带的.stringify方法来判断：

```js
if(JSON.stringify(Obj) == '{}' ){
    console.log('空对象');
}
```

- 使用ES6新增的方法Object.keys()来判断：

```js
if(Object.keys(Obj).length < 0){
    console.log('空对象');
}
```

### 23. typeof null 的结果是什么，为什么？

typeof null 的结果是Object。 因为历史遗留问题。

在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 类型标签(1-3 bits) 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型

```
000: object   - 当前存储的数据指向一个对象。
  1: int      - 当前存储的数据是一个 31 位的有符号整数。
010: double   - 当前存储的数据指向一个双精度的浮点数。
100: string   - 当前存储的数据指向一个字符串。
110: boolean  - 当前存储的数据是布尔值。
```

如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。

有两种特殊数据类型： 

● undefined的值是 (-2)30(一个超出整数范围的数字)； 

● null 的值是机器码 NULL 指针(null 指针的值全是 0) 那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object

## 二、ES6

### 1. let ,const, var区别

块级作用域，重复声明，变量提升，暂时性死区

### 2. const 对象的属性可以更改吗

### 3. 如果new一个箭头函数会怎样

### 4. 箭头函数和普通函数的区别

### 5. 箭头函数的this指向哪里

### 6. 🐒扩展运算符的作用

### 7. 🐒proxy实现什么功能

### 8. 🐒对对象与数组的解构的理解

### 9. 如何提取高度嵌套的对象里的指定属性

### 10. 对rest参数的理解

### 11. es6中模板语法与字符串的处理

### 12. 数组常用的方法

1. 操作方法

   - 增
     - push()：方法接收任意数量的参数，并将它们添加到数组末尾，返回数组的最新长度
     - unshift()：在数组开头添加任意多个值，然后返回新的数组长度
     - splice()：传入三个参数，分别是开始位置、0（要删除的元素数量）、插入的元素，返回空数组
     - concat()：首先会创建一个当前数组的副本，然后再把它的参数添加到副本末尾，最后返回这个新构建的数组，不会影响原始数组

   - 删
     - pop()：用于删除数组的最后一项，同时减少数组的`length` 值，返回被删除的项
     - shift()：用于删除数组的第一项，同时减少数组的`length` 值，返回被删除的项
     - splice()：传入两个参数，分别是开始位置，删除元素的数量，返回包含删除元素的数组
     - slice()：不影响原数组：创建一个包含原有数组中一个或多个元素的新数组，不会影响原始数组

   - 改

     splice():传入三个参数，分别是开始位置，要删除元素的数量，要插入的任意多个元素，返回删除元素的数组，对原数组产生影响

   - 查
     - indexOf():返回要查找的元素在数组中的位置，如果没找到则返回 -1
     - includes():返回要查找的元素在数组中的位置，找到返回`true`，否则`false`
     - find():返回第一个匹配的元素

2. 转换方法：join():接收一个参数，即字符串分隔符，返回包含所有项的字符串

3. 排序方法：

   - reverse():顾名思义，将数组元素方向反转
   - sort():接受一个比较函数，用于判断哪个值应该排在前面

4. 迭代/遍历方法

- some():对数组每一项都运行传入的函数，如果有一项函数返回 true ，则这个方法返回 true

- every():对数组每一项都运行传入的函数，如果对每一项函数都返回 true ，则这个方法返回 true

- forEach():对数组每一项都运行传入的函数，没有返回值

- filter():对数组每一项都运行传入的函数，函数返回 `true` 的项会组成数组之后返回

- map():对数组每一项都运行传入的函数，返回由每次函数调用的结果构成的数组

  

### 13. 字符串的操作方法

1. 操作方法

   - 增

     - concat:用于将一个或多个字符串拼接成一个新字符串

   - 删

     这里的删的意思并不是说删除原字符串的内容，而是创建字符串的一个副本，再进行操作

     - Slice 
     - substr()
     - Substring()

   - 改

     - trim()、trimLeft()、trimRight()
     - repeat()
     - padStart()、padEnd()
     - toLowerCase()、 toUpperCase()

   - 查

     - chatAt():返回给定索引位置的字符，由传给方法的整数参数指定
     - indexOf():从字符串开头去搜索传入的字符串，并返回位置（如果没找到，则返回 -1 ）
     - startWith():从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值
     - includes():从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值

2. 转换方法

   - Split:把字符串按照指定的分割符，拆分成数组中的每一项

3. 模版匹配方法

   - match():接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，返回数组
   - search():接收一个参数，可以是一个正则表达式字符串，也可以是一个`RegExp`对象，找到则返回匹配索引，否则返回 -1
   - replace():接收两个参数，第一个参数为匹配的内容，第二个参数为替换的元素（可用函数

### 14. 深拷贝和浅拷贝

<mark>浅拷贝</mark>，指的是创建新的数据，这个数据有着原始数据属性值的一份精确拷贝

如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，拷贝的就是内存地址

- `Object.assign`
- `Array.prototype.slice()`, `Array.prototype.concat()`
- 使用拓展运算符实现的复制

<mark>深拷贝</mark>

深拷贝开辟一个新的栈，两个对象属完成相同，但是对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性

常见的深拷贝方式有：

- _.cloneDeep()
- jQuery.extend()
- JSON.stringify()
- 手写循环递归

### 15. 闭包

一个函数和对其周围状态（lexical environment，词法环境）的引用捆绑在一起（或者说函数被引用包围），这样的组合就是闭包（closure）

**使用场景**

1. 柯里化函数：目的在于避免频繁调用具有相同参数函数的同时，又能够轻松的重用

2. 使用闭包模拟私有方法：在`JavaScript`中，没有支持声明私有变量，但我们可以使用闭包来模拟私有方法

   通过使用闭包来定义公共函数，并令其可以访问私有函数和变量，这种方式也叫模块方式

   两个计数器 `Counter1` 和 `Counter2` 是维护它们各自的独立性的，每次调用其中一个计数器时，通过改变这个变量的值，会改变这个闭包的词法环境，不会影响另一个闭包中的变量

例如计数器、延迟调用、回调等闭包的应用，其核心思想还是创建私有变量和延长变量的生命周期

**闭包注意事项**

如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响

在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因在于每个对象的创建，方法都会被重新赋值。

### 16. 作用域

函数和变量能被访问的区域

- 全局作用域：任何不在函数中或是大括号中声明的变量，都是在全局作用域下，全局作用域下声明的变量可以在程序的任意位置访问
- 函数作用域：函数作用域也叫局部作用域，如果一个变量是在函数内部声明的它就在一个函数作用域下面。这些变量只能在函数内部访问，不能在函数以外去访问
- 块级作用域：ES6引入了`let`和`const`关键字,和`var`关键字不同，在大括号中使用`let`和`const`声明的变量存在于块级作用域中。在大括号之外不能访问这些变量

**作用域链**

当在`Javascript`中使用一个变量的时候，首先`Javascript`引擎会尝试在当前作用域下去寻找该变量，如果没找到，再到它的上层作用域寻找，以此类推直到找到该变量或是已经到了全局作用域

### 17. this对象的理解

`this` 关键字是函数运行时自动生成的一个内部对象，只能在函数内部使用，总指向调用它的对象

### 18. JavaScript中执行上下文和执行栈是什么？

- 全局执行上下文：只有一个，浏览器中的全局对象就是 `window`对象，`this` 指向这个全局对象
- 函数执行上下文：存在无数个，只有在函数被调用的时候才会被创建，每次调用函数都会创建一个新的执行上下文
- 执行栈，也叫调用栈，具有 LIFO（后进先出）结构，用于存储在代码执行期间创建的所有执行上下文

### 19. ajax

即异步的`JavaScript` 和`XML`，是一种创建交互式网页应用的网页开发技术，可以在不重新加载整个网页的情况下，与服务器交换数据，并且更新部分网页

`Ajax`的原理简单来说通过`XmlHttpRequest`对象来向服务器发异步请求，从服务器获得数据，然后用`JavaScript`来操作`DOM`而更新页面

```js
//封装一个ajax请求
function ajax(options) {
    //创建XMLHttpRequest对象
    const xhr = new XMLHttpRequest()


    //初始化参数的内容
    options = options || {}
    options.type = (options.type || 'GET').toUpperCase()
    options.dataType = options.dataType || 'json'
    const params = options.data

    //发送请求
    if (options.type === 'GET') {
        xhr.open('GET', options.url + '?' + params, true)
        xhr.send(null)
    } else if (options.type === 'POST') {
        xhr.open('POST', options.url, true)
        xhr.send(params)

    //接收请求
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            let status = xhr.status
            if (status >= 200 && status < 300) {
                options.success && options.success(xhr.responseText, xhr.responseXML)
            } else {
                options.fail && options.fail(status)
            }
        }
    }
}
```

### 20. eventLoop

`JavaScript`是一门单线程的语言，意味着同一时间内只能做一件事，但是这并不意味着单线程就是阻塞，而实现单线程非阻塞的方法就是事件循环

![img](https://static.vue-js.com/6e80e5e0-7cb8-11eb-85f6-6fac77c0c9b3.png)

![image-20210908092808139](/Users/chenruo/Library/Application Support/typora-user-images/image-20210908092808139.png)

`1`=>`'new Promise'`=> `3` => `'then'` => `2`

1. 微任务宏任务
   - 执行一个宏任务，如果遇到微任务就将它放到微任务的事件队列中
   - 当前宏任务执行完成后，会查看微任务的事件队列，然后将里面的所有微任务依次执行完
2. Await async

### 21. jsonp

**以下是Jsonp解决跨域：**

根据浏览器同源策略，所谓同源就是协议、主机、端口号都相同时成为同源。a 域的js不能直接访问 b域名的信息，但是script 标签的src属性可以跨域引用文件，jsonp是请求之后后台包装好一段json，并且把数据放在一个callback函数，返回一个js文件，动态引入这个文件，下载完成js之后，会去调用这个callback通过这样访问数据。

为了实现跨域请求，可以通过script标签实现跨域请求，然后再服务端输出JSON数据并执行回调callback函数，从而解决跨域数据请求。**jsonp的核心则是动态添加`<script>`标签来调用服务器提供的js脚本。**

首先在客户端注册一个callback，然后把callback的名字传给服务器。此时，服务器先生成json数据，然后以javascript语法的方式，生成function，function名字就是传递上来I带参数jsonp。最后将json数据直接以入参的方式，放置function中，这样就生成js语法的文档，返回给客户端。客户端浏览器，解析script标签，并执行返回javascript文档，此时数据作为参数，传入了客户端预先定义好的callback函数里。简单的说，就是利用script标签没有跨域限制的“漏洞”来达到与第三方通讯的目的。

总结一下，json 是一种数据格式，jsonp 是一种数据调用的方式，带callback的json就是jsonp。

**缺点：这种方式只支持get方式。**

## 三、javaScript基础 

1. new操作符的实现原理
   - new关键字会首先创建一个空对象
   - 将这个空对象的原型对象指向构造函数的原型属性，从而继承原型上的方法
   - 将this指向这个空对象，执行构造函数中的代码，以获取私有属性
   - 如果构造函数返回了一个对象res，就将该返回值res返回，如果返回值不是对象，就将创建的对象返回
     理解了new的原理，手动实现就很简单了.
   
2. 🐒map和Object的区别

3. 🐒map和weakMap的区别

4. 🐒JavaScript有哪些内置对象

5. 常用的正则表达式有哪些?

6. 对JSON的理解

7. JavaScript脚本延迟加载的方式有哪些

8. JavaScript类数组对象的定义?

9. 数组有哪些原生方法?

10. Unicode、 UTF-8、UTF-16、UTF...

11. 常见的位运算符有哪些?其计算规...

12. 为什么函数的arguments参数是类...

13. 什么是DOM和BOM?

14. 对类数组对象的理解，如何转化为数

15. escape、 encodeURI、encodeURIC

16. 对AJAX的理解，实现-个AJAX请求

17. JavaScript为什么要进行变量提升，

18. 什么是尾调用，使用尾调用有什么好.

19. ES6模块与CommonJS模块有什么异.

20. 常见的DOM操作有哪些

21. use strict是什么意思?使用它区别...

22. 如何判断一个对象是否属于身T ?

23. 强类型语言和弱类型语言的区别

24. 解释性语言和编译型语言的区品

### 25. for..in和for.. .of的区别

for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下 

for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名； 

for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链； 

对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值； 

总结：for...in 循环主要是为了遍历对象而生，不适用于遍历数组；for...of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。

26. 如何使用for.. .of遍历对象

27. ajax、 axios、 fetch的区别

28. 数组遍历方法

29. foreach和map的区别

## 四、原型与原型链

1. 对原型、原型链的理解
2. 原型修改、重写
3. 原型链指向
4. 原型链的终点是什么?如何打印出原...
5. 如何获得对象非原型链上的属性?

## 五、执行上下文/作用域链/闭包

1. 对闭包的理解

   闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

   **优点：**

   - 希望一个变量长期存储在内存中。
   - 避免全局变量的污染。
   - 私有成员的存在。

   **缺点：**

   - 常驻内存，增加内存使用量。
   - 使用不当会很容易造成内存泄露。

2. 对作用域、作用域链的理解

3. 对执行上下文的理解

## 六、this/call/apply/bind

1. 对this对象的理解
2. call() 和apply()的区别?
3. 实现call、apply 及bind函数

## 七、异步编程

1. 异步编程的实现方式?
2. setTimeout、Promise、 Async/Aw...
3. 对Promise的理解
4. Promise的基本用法
5. Promise解决了什么问题
6. Promise. all和Promise.race的区别的...
7. 对async/await的理解
8. await到底在等啥?
9. async/await的优势
10. async/await对比Promise的优势
11. async/await如何捕获异常
12. 并发与并行的区别?
13. 什么是回调函数?回调函数有什么缺..

## 八、面向对象

1. 对象创建的方式有哪些?
2. 对象继承的方式有哪些?

## 九、垃圾回收机制

1. 浏览器的垃圾回收机制
2. 哪些情况会导致内存泄漏

# 二、Vue

https://slbyml.github.io/QA/vue.html#%E7%AE%80%E8%BF%B0vue%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86

## 一、Vue基础

### 1. Vue的基本原理

   当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter/setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。

   ![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1620128979608-f7465ffc-9411-43e3-a6bc-96ab44dd77df.png)

### 2. 双向数据绑定的原理

   ![](https://static.vue-js.com/e5369850-3ac9-11eb-85f6-6fac77c0c9b3.png)

   ![Draft-29.jpg](http://ww1.sinaimg.cn/large/005NUwyggy1gu5l5twqptj61nx1acdsi02.jpg)

   [Link](https://vue3js.cn/interview/vue/bind.html#%E4%BA%8C%E3%80%81%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88)

   1. `new Vue()`首先执行初始化，对`data`执行响应化处理，这个过程发生`Observe`中
   2. 同时对模板执行编译，找到其中动态绑定的数据，从`data`中获取并初始化视图，这个过程发生在`Compile`中
   3. 同时定义⼀个更新函数和`Watcher`，将来对应数据变化时`Watcher`会调用更新函数
   4. 由于`data`的某个`key`在⼀个视图中可能出现多次，所以每个`key`都需要⼀个管家`Dep`来管理多个`Watcher`
   5. 将来data中数据⼀旦发生变化，会首先找到对应的`Dep`，通知所有`Watcher`执行更新函数

### 3. 使用Object.defineProperty()来进行数据劫持有什么缺点

   不能修改属性(数组，对象)，无法触发组件的重新渲染

### 4. MVVM、MVC、MVP的区别

   Model -> person{age:18,name:""li}

   Controller / viewmodel-> `person.name = 'Homer';person.age = 51;`

   ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/27/16af72cd60c25062~tplv-t2oaga2asx-watermark.awebp)

   ![](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/5/27/16af920a988c5f66~tplv-t2oaga2asx-watermark.awebp)

   MVVM模式的优点:

   - 低耦合:View可以独立于Model变化和修改,一个ViewModel可以绑定到不同的View上,当View变化的时候Model可以不变,当Model变化的时候View也可以不变。
   - 可重用性: 可以把一些视图逻辑放在一个ViewModel里面,让很多View重用这段视图逻辑。
   - 独立开发: 开发人员可以专注于业务逻辑和数据的开发,设计人员可以专注于页面的设计。

5. Computed和Watch的区别

   - computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 

   - watch 侦听器 : 更多的是观察的作用，无缓存性，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。

### 6. Computed和Methods的区别

### 7. 🐒slot是什么?有什么作用?原理是什么

### 8. 过滤器的作用，如何实现一个过滤器

### 9. 如何保存页面的当前的状态

### 10. 常见的事件修饰符及其作用

### 11. v-if、 v-show、 v-html的原理

### 12. v-if和v- show的区别

### 13. 🐒v-model是如何实现的，语法糖实际上是什么

### 14. 🐒v-model可以被用在自定义组件上吗？如果可以，如何使用？

### 15. data为什么是一个函数而不是对象

### 16. 🐒对keep-alive的理解，它是如何实现的，具体缓存的是什么？

### 17. 🌟$nextTick原理及作用

在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM

eventLoop,本质是使用js的异步回调队列实现vue框架中自己的异步回调

Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOM操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。

### 18. Vue中给data中的对象属性添加一个新属性时会发生什么？如何解决？

$set()

### 19. 🐒Vue中封装的数组方法有哪些，其如何实现页面更新

### 20. Vue单页应用与多页应用的区别

数据传递，资源文件，结构

### 21. Vue template到render的过程

- 把模板编译为render函数
- 实例进行挂载, 根据根节点render函数的调用，递归的生成虚拟dom
- 对比虚拟dom，渲染到真实dom
- 组件内部data发生变化，组件和子组件引用data作为props重新调用render函数，生成虚拟dom, 对比虚拟dom，渲染到真实dom

### 22. Vue data中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗。

### 23. 🐒简述mixin、extends 的覆盖逻辑

### 24. 🐒描述下Vue自定义指令

### 25. 子组件可以直接改变父组件的数据吗？

$emit

### 26. 🐒Vue是如何收集依赖的?

### 27. 🐒对React和Vue的理解，它们的异同

核心库，构建工具，虚拟DOM，数据传递，组件化

数据流，模板写法，高阶组件，diff算法

### 28. Vue的优点

轻量级框架，简单易学国人开发，双向数据绑定，组件化，虚拟dom，运行速度快

### 29. assets和static的区别

### 30. delete和Vue.delete删除数组的区别

### 31. vue如何监听对象或者数组某个属性的变化

### 32. 🐒什么是mixin ?

### 33. 🐒Vue模版编译原理

### 34. 对SSR的理解

    `Server-Side Rendering` 我们称其为`SSR`，意为服务端渲染
    
    SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端
    
    - seo：搜索引擎优先爬取页面`HTML`结构，使用`ssr`时，服务端已经生成了和业务想关联的`HTML`，有利于`seo`
    - 首屏呈现渲染：用户无需等待页面所有`js`加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）

### 35. 🐒Vue的性能优化有哪些

### 36. 对SPA单页面的理解，它的优缺点分别是什么?

    - 用户体验好，只刷新部分数据，服务器压力小，前后端职责分离
    - 初次加载消耗多，路由不能使用浏览器的前进后退，seo难度大

### 37. template和jsx的有什么分别?

    复杂组件，结构和逻辑习惯

### 38. vue初始化页面闪动问题

### 39. 🐒extend有什么作用

### 40. 🐒mixin和mixins区别

### 41. MVVM的优缺点?

- 降低代码耦合
- 提高可测试性
- 自动更新DOM
- Bug难调试
- 大型的图形应用程序，viewmodel的构建和维护成本会比较高

### 42. v-if和v-for哪个优先级更高?如果同时出现，应该如何优化？

- V-for -> v-if
- 如果避免出现这种情况，则在外层嵌套`template`（页面渲染不生成`dom`节点），在这一层进行v-if判断，然后在内部进行v-for循环
- 如果条件出现在循环内部，可通过计算属性`computed`提前过滤掉那些不需要显示的项

### 43. 🐒对Vue组件化的理解

### 44. 🐒对vue设计原则的理解

### 45. 常见的Vue性能优化方法

- 路由懒加载
- Keep alive
- v-show敷用dom
- 长列表性能优化
- 图片懒加载

### 46. v-model的实现原理

## 二、生命周期

### 1. 说一下Vue的生命周期

   ![](https://static.vue-js.com/44114780-3aca-11eb-85f6-6fac77c0c9b3.png)

### 2. Vue子组件和父组件执行顺序

### 3. created和mounted的区别

   组件实例创建完成，DOM节点渲染完成。可以获取节点，页面闪动。

### 4. 一般在哪个生命周期请求异步数据

   Created,beforeMount,mounted,(data)

   - 更快获取数据
   - SSR

### 5. keep-alive中的生命周期哪些

## 三、组件通信

### 1. props  / $emit
### 2. eventBus ($emit / $on) 
### 3. 依赖注入(project / inject)
### 4. ref / $refs
### 5. $parent / $children
### 6. $attrs / $listeners
### 7. 总结

## 四、路由

### 1. Vue- Router的懒加载如何实现
### 2. 路由的hash和history模式的区别
### 3. 如何获取页面的hash变化
### 4. $route和$router的区别
### 5. 如何定义动态路由?如何获取传过来的.
### 6. Vue-router路由钩子在生命周期的体现
### 7. Vue-router跳转和location.href有什...
### 8. params和query的区别
### 9. Vue-router导航守卫有哪些
### 10. 对前端路由的理解

## 五、VueX

### 1. Vuex的原理

   ![vuex2.jpg](http://ww1.sinaimg.cn/large/005NUwyggy1gu5tw21u1bj61nx1acwn002.jpg)

### 2. Vuex中action和mutation的区别

### 3. Vuex和localStorage的区别

   存储的方式(内存，文件)，数据响应，永久性

### 4. Redux和Vuex有什么区别，它们的共同思想

  区别：

  - vuex 弱化 dispatch，通过commit进行 store状态的一次更变;

  - 取消了action概念，不必传入特定的 action形式进行指定变更;

  - 弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易

  共同思想：

  - 单—的数据源
  - 变化可以预测

### 5. 为什么要用Vuex或者Redux

   组件数据传参的时候多层嵌套非常繁琐，也不利于兄弟组件之间的数据传递，所以需要把组件的共享状态抽离出来，以全局单例模式管理。任何组件都能获取或者触发行为。这样代码更结构化，也更容易进行维护。

### 6. Vuex有哪几种属性? 

### 7. Vuex和单纯的全局对象有什么区别?

   响应式，不能直接更新对应状态

### 8. 为什么Vuex的mutation中不能做异步操作？

  - 方便跟踪每一个数据状态的变化
  - mutation执行完后devtools(浏览器调试器)就可以打快照存下来，可以实现time-travel，如果异步就无法对状态进行跟踪，调试会有困难。

### 9. Vuex的严格模式是什么，有什么作用，如何开启？

   在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。

### 10. 🐒如何在组件中批量使用Vuex的getter属性

    使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中 JavaScript 复制代码

### 11. 🐒如何在组件中重复使用Vuex的mutation

    使用mapMutations辅助函数

## 六、Vue 3.0

### 1. Vue3.0有什么更新

   [link](https://vue3js.cn/interview/vue/vue3_vue2.html#%E4%BA%8C%E3%80%81vue3%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7)

   更小更快(优化)更友好（ts,composition api,开放更多底层功能）+响应性

### 2. defineProperty和proxy的区别

   兼容性，监听内容

### 3. Vue3.0为什么要用proxy?

   - `Object.defineProperty`只能遍历对象属性进行劫持，`Proxy`直接可以劫持整个对象，并返回一个新对象，我们可以只操作新的对象达到响应式目的

   - `Proxy`可以直接监听数组的变化（`push`、`shift`、`splice`），`Proxy`有多达13种拦截方法,不限于`apply`、`ownKeys`、`deleteProperty`、`has`等等，这是`Object.defineProperty`不具备的

   - `Proxy` 不兼容IE，也没有 `polyfill`, `defineProperty` 能支持到IE9

### 4. Vue 3.0中的Vue Composition API?

   - 逻辑组织
   - 逻辑复用
   - 在逻辑组织和逻辑复用方面，`Composition API`是优于`Options API`
   - 因为`Composition API`几乎是函数，会有更好的类型推断。
   - `Composition API`对 `tree-shaking` 友好，代码也更容易压缩
   - `Composition API`中见不到`this`的使用，减少了`this`指向不明的情况
   - 如果是小型组件，可以继续使用`Options API`，也是十分友好的

### 5. 🐒Composition API与 React Hook很像，区别是什么？

## 七、虚拟DOM

### 1. 对虚拟DOM的理解?

   实际上它只是一层对真实`DOM`的抽象，以`JavaScript` 对象 (`VNode` 节点) 作为基础的树，用对象的属性来描述节点，最终可以通过一系列操作使这棵树映射到真实环境上。

### 2. 🐒虚拟DOM的解析过程

### 3. 为什么要用虚拟DOM

   - 虚拟 DOM 最大的优势1----是 diff 算法，减少 JavaScript 操作真实 DOM 的带来的性能消耗。

   - 虚拟 DOM 最大的优势2----在于抽象了原本的渲染过程，实现了跨平台的能力，而不仅仅局限于浏览器的 DOM，可以是安卓和 IOS 的原生组件，可以是近期很火热的小程序，也可以是各种GUI

### 4. 虚拟DOM真的比真实DOM性能好吗

### 5. DIFF算法的原理

   - 当数据发生改变时，订阅者`watcher`就会调用`patch`给真实的`DOM`打补丁

   - 通过`isSameVnode`进行判断，相同则调用`patchVnode`方法

     patchVnode做了以下操作：

     - 找到对应的真实`dom`，称为`el`
     - 如果都有都有文本节点且不相等，将`el`文本节点设置为`Vnode`的文本节点
     - 如果`oldVnode`有子节点而`VNode`没有，则删除`el`子节点
     - 如果`oldVnode`没有子节点而`VNode`有，则将`VNode`的子节点真实化后添加到`el`
     - 如果两者都有子节点，则执行`updateChildren`函数比较子节点

     updateChildren主要做了以下操作：

     - 设置新旧`VNode`的头尾指针
     - 新旧头尾指针进行比较，循环向中间靠拢，根据情况调用`patchVnode`进行`patch`重复流程、调用`createElem`创建一个新节点，从哈希表寻找 `key`一致的`VNode` 节点再分情况操作

   

### 6. Vue中key的作用

   > key是给每一个vnode的唯一id，也是diff的一种优化策略，可以根据key，更准确， 更快的找到对应的vnode节点

### 7. 为什么不建议用index作为key?

   因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2...这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。

   导致的问题就是以前的数据和重新渲染后的数据随着 key 值的变化从而没法建立关联关系，这就失去了 key 值存在的意义

# 三、React

### 简单介绍react

React是Facebook开发的一款JS库,React不是一个MVC框架，它是构建易于可重复调用的web组件，侧重于UI, 也就是view层

其次React是单向的从数据到视图的渲染，非双向数据绑定

不直接操作DOM对象，而是通过虚拟DOM通过diff算法以最小的步骤作用到真实的DOM上。

不直接操作DOM，大多数时间只是对 virtual DOM 进行编程

### 单项数据流

单向数据流这种模式十分适合跟 React 搭配使用。它的主要思想是组件不会改变接收的数据。它们只会监听数据的变化，当数据发生变化时它们会使用接收到的新值，而不是去修改已有的值。当组件的更新机制触发后，它们只是使用新值进行重新渲染而已。

## 一、✨组件基础

### 1. React事件机制

是 `React`模拟原生 `DOM`事件所有能力的一个事件对象。即浏览器原生事件的跨浏览器包装器。举例onClick,事件没有绑定在真实DOM上，而是通过事件代理，绑定在最外层。减少内存消耗，组件卸载销毁的时候统一订阅和移除事件。（阻止事件发生不能用stopPropogation,而是要用prevent default ）

### 2. React的事件和普通的HTML事件有什么不同。

   命名方式，事件阻止方式

### 3. React组件中怎么做事件代理?它的原理是什么？

   事件冒泡，绑定到root上(17.0.0版本)

   原理：1. 事件委派 2. 自动绑定

   - 事件委派：React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。 

   - 自动绑定：React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。

### 4. 🐒React高阶组件、Render props、hooks有什么区别，为什么不断迭代？

### 5. 🐒对React-Fiber的理解，它解决了什么问题？

  `JavaScript`引擎和页面渲染引擎两个线程是互斥的，js线程长时间占用主线程，渲染层会不断等待，会造成用户界面卡顿。

### 6. React.Component和React.PureComponent的区别。

   PureComponent表示一个纯组件，会自动调用shouldComponentUpdate,这个生命周期进行的是浅比较，当组件更新时，如果组件的props或者state都没有改变，render函数就不会触发。省去虚拟DOM的生成和对比过程，达到提升性能的目的。可以用来优化React程序，减少render函数执行的次数，从而提高组件的性能。

### 7. 🐒Component, Element, Instance之间的区别和联系

### 8. 🐒React.createClass和extends Component的区别?

   1. 语法区别

      ```jsx
      import React from 'react';
      
      const Contacts = React.createClass({  
        render() {
          return (
            <div></div>
          );
        }
      });
      
      export default Contacts;  
      ```

      ```jsx
      import React from 'react';
      
      class Contacts extends React.Component {  
        constructor(props) {
          super(props);
        }
        render() {
          return (
            <div></div>
          );
        }
      }
      
      export default Contacts;  
      ```

      

   2. propType 和 getDefaultProps,propType/defaultProps

   3. this区别,React.createClass会绑定class，而extends不会

      

### 9. React高阶组件是什么，和普通组件的区别，适用什么场景？

在`React`中，高阶组件即接受一个或多个组件作为参数并且返回一个组件，本质也就是一个函数，并不是一个组件。



在实际应用中，常常用于与核心业务无关但又在多个模块使用的功能，如权限控制、日志记录、数据校验、异常处理、统计上报等

### 10. 🐒对componentWillReceiveProps的理解

    在这个生命周期中，可以在子组件的render函数执行前获取新的props，从而更新子组件自己的state。

### 11. 哪些方法会触发React重新渲染?

   - setState(),传入null的时候不会触发render
   - 父组件重新渲染

### 12. React如何判断什么时候重新渲染组件？

   - 类组件调用 setState 修改状态（一定会重新渲染）
   - 函数组件通过`useState hook`修改状态(不一定，根据数组是否进行监听判断)
   - `useState` 会判断当前值有无发生改变确定是否执行`render`方法，一旦父组件发生渲染，子组件也会渲染

### 13. React声明组件有哪几种方法，有什么不同？

   函数式，es6类式，es5原生createClass

   This，props，hooks

### 14. 🐒对有状态组件和无状态组件的理解及使用场景

### 15. 对React中Fragment的理解，它的使用场景

### 16. React如何获取组件对应的DOM元素?

    Ref,createRef，
    
    `<p ref="info">span</p>`
    
    `<p ref={ele => this.info = ele}></p>`
    
    ref 16之前的版本字符串方式或者函数式
    
    createRef 16的版本

### 17. React中可以在render访问refs吗?为什么？

不可以，render 阶段 DOM 还没有生成，无法获取 DOM。DOM 的获取需要在 pre-commit 阶段和 commit 阶段。

### 18. 🐒对React的插槽(Portals)的理解，如何使用，有哪些使用场景？

### 19. 在React中如何避免不必要的render?

   - shouldComponentUpdate

   - PureComponent

   - React.memo:用来缓存组件的渲染，避免不必要的更新，其实也是一个高阶组件，与 `PureComponent` 十分类似。但不同的是， `React.memo` 只能用于函数组件

     ```jsx
     const Funcomponent = ()=> {
         return (
             <div>
                 Hiya!! I am a Funtional component
             </div>
         )
     }
     const MemodFuncComponent = React.memo(Funcomponent)
     ```

### 20. 🐒对React-Intl的理解，它的工作原理

### 21. 对React context的理解

Context 提供了一种在组件之间共享此类值的方式，而不必显式地通过组件树的逐层传递 props。

### 22. 🐒为什么React并不推荐优先考虑使用context

### 23. React中什么是受控组件和非控组件?应用场景？

   - 受控组件，简单来讲，就是受我们控制的组件，组件的状态全程响应外部数据。组件添加value值和onChange事件

   - 非受控组件，简单来讲，就是不受我们控制的组件。一般情况是在初始化的时候接受外部数据，然后自己在内部存储其自身状态。通过ref获取数据

   ![](https://static.vue-js.com/f28aed20-df2f-11eb-ab90-d9ae814b240d.png)

### 24. React中refs的作用是什么?有哪些应用场景？

 Refs 提供了一种方式，用于访问在 render 方法中创建的 React 元素或 DOM 节点。过多使用`refs`，会使组件的实例或者是`DOM`结构暴露，违反组件封装的原则

   但下面的场景使用`refs`非常有用：

   - 对Dom元素的焦点控制、内容选择、控制
   - 对Dom元素的内容设置及媒体播放
   - 对Dom元素的操作和对组件实例的操作
   - 集成第三方 DOM 库

### 25. React中除了在构造函数中绑定this，还有别的方式吗？

### 26. React组件的构造函数有什么作用?

   - 通过将对象分配给this.state来初始化本地状态

   - 将事件处理程序方法绑定到实例上

### 27. React.forwardRef是什么?它有什么作用？

 React.forwardRef 会创建一个React组件，这个组件能够将其接受的 ref 属性转发到其组件树下的另一个组件中。

   - 转发 refs 到 DOM 组件 
   - 在高阶组件中转发 refs

### 28. 类组件与函数组件有什么异同?

## 二、✨数据管理

### 1. 🐒React setState调用的原理

   关于`state`方法的定义是从`React.Component`中继承，定义的源码如下：

   ```js
   Component.prototype.setState = function(partialState, callback) {
     invariant(
       typeof partialState === 'object' ||
         typeof partialState === 'function' ||
         partialState == null,
       'setState(...): takes an object of state variables to update or a ' +
         'function which returns an object of state variables.',
     );
     this.updater.enqueueSetState(this, partialState, callback, 'setState');
   };
   ```

### 2. 🐒React setState调用之后发生了什么?是同步还是异步？

   - 在组件生命周期或React合成事件中，setState是异步

     因为react可以控制。

   - 在setTimeout或者原生dom事件中，setState是同步，因为react无法控制原生事件。

### 3. React中的setState批量更新的过程是什么？

   放入队列，合成一次，即使多次触发，只保留最后一次的更新

### 4. React中有使用过getDefaultProps吗？它有什么作用？

   通过实现组件的getDefaultProps，对属性设置默认值（ES5的写法

### 5. React中setState的第二个参数作用是什么？

### 6. React中的setState和replaceState的区别是什么？

 1. 参数都相同
 2. 用法不同⬇️

  - setState 是修改其中的部分状态，相当于 Object.assign，只是覆盖，不会减少原来的状态。
  - replaceState 是完全替换原来的状态，相当于赋值，将原来的 state 替换为另一个对象，如果新状态属性减少，那么 state 中就没有这个状态了。

### 7. 在React中组件的this. state和setState/useState()有什么区别？

  初始化状态和修改状态

![image-20210907162638708](/Users/chenruo/Library/Application Support/typora-user-images/image-20210907162638708.png)

### 8. 🐒state是怎么注入到组件的，从reducer到组件经历了什么样的过程？

  通过connect和mapStateToProps将state注入到组件中。

### 9. React组件的state和props有什么区别?

  相同点：

  - 两者都是 JavaScript 对象
  - 两者都是用于保存信息
  - props 和 state 都能触发渲染更新

  区别：

  - props 是外部传递给组件的，而 state 是在组件内被组件自己管理的，一般在 constructor 中初始化
  - props 在组件内部是不可修改的，但 state 在组件内部可以进行修改
  - state 是多变的、可以修改

### 10. React中的props为什么是只读的?

    this.props就是汲取了纯函数的思想。props的不可以变性就保证的相同的输入，页面显示的内容是一样的，并且不会产生副作用

### 11. 在React中组件的props改变时更新组件有哪些方法？

getDerivedStateFromProps

componentWillReceiveProps

### 12. React中怎么检验props?验证props的目的是什么？


## 三、✨生命周期

### 1. React的生命周期有哪些?

   ![](https://cdn.nlark.com/yuque/0/2021/png/1500604/1611914193870-a5a93315-a094-40aa-959a-e3e3c58c8a96.png)

![image-20210906144816223](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906144816223.png)

   ![image-20210907110123380](/Users/chenruo/Library/Application Support/typora-user-images/image-20210907110123380.png)

![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/791da7c43d3c4f45862f909ce38c882c~tplv-k3u1fbpfcp-watermark.awebp)   

React常见生命周期的过程大致如下： 

   1. 挂载阶段，首先执行constructor构造方法，来创建组件
   2. 创建完成之后，就会执行render方法，该方法会返回需要渲染的内容 
   3. 随后，React会将需要渲染的内容挂载到DOM树上 
   4.  挂载完成之后就会执行componentDidMount生命周期函数
   5. 如果我们给组件创建一个props（用于组件通信）、调用setState（更改state中的数据）、调用forceUpdate（强制更新组件）时，都会重新调用render函数 
   6. render函数重新执行之后，就会重新进行DOM树的挂载
   7. 挂载完成之后就会执行componentDidUpdate生命周期函数 
   8. 当移除组件时，就会执行componentWillUnmount生命周期函数

### 2. React废弃了哪些生命周期?为什么?

   - componentWillMount
   - componentWillReceiveProps
   - componentWillUpdate

   被废弃的三个函数都是在render之前，因为fiber的出现，很可能因为高优先级任务的出现而打断现有任务导致它们会被执行多次。

### 3. getDerivedStateFromProps React 16.X中props改变后在哪个生命周期中处理？

   在getDerivedStateFromProps中进行处理。

第二种场景是一些组件需要在用户输入时有一个中间状态，当触发某个操作时再把中间结果提交给上层。以一个 `input`为例，在过去我们通过 `componentWillReceiveProps`在上层组件触发重绘时把数据同步到 `state`：

   ```js
   static getDerivedStateFromProps(nextProps, prevState) {
       const {type} = nextProps;
       // 当传入的type发生变化的时候，更新state
       if (type !== prevState.type) {
           return {
               type,
           };
       }
       // 否则，对于state不进行任何操作
       return null;
   }
   ```

### 4. React性能优化在哪个生命周期?优化的原理是什么？

shouldComponentUpdate提供了两个参数nextProps和nextState，表示下一次props和下一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。

   

   需要注意，在进行新旧对比的时候，是浅对比，也就是说如果比较的数据时引用数据类型，只要数据的引用的地址没变，即使内容变了，也会被判定为true。

   ```js
   shouldComponentUpdate(nexrProps) {
       if (this.props.num === nexrProps.num) {
           return false
       }
       return true;
   }
   ```

### 5. 🐒state和props触发更新的生命周期分别有什么区别？

### 6. React中发起网络请求应该在哪个生命周期中进行？为什么？

   componentwillMount->会执行两次，服务端，客户端

   componentDidMount

   componentDidMount方法中的代码，是在组件已经完全挂载到网页上才会调用被执行，所以可以保证数据的加载。此外，在这方法中调用setState方法，会触发重新渲染。所以，官方设计这个方法就是用来加载外部数据用的，或处理其他的副作用代码。与组件上的数据无关的加载，也可以在constructor里做，但constructor是做组件state初绐化工作，并不是做加载数据这工作的，constructor里也不能setState，还有加载的时间太长或者出错，页面就无法加载出来。所以有副作用的代码都会集中在componentDidMount方法里。

### 7. React 16中新生命周期有哪些

   1. React16新的生命周期弃用了componentWillMount、componentWillReceiveProps，componentWillUpdate
   2. 新增了getDerivedStateFromProps、getSnapshotBeforeUpdate来代替弃用的三个钩子函数（componentWillMount、componentWillReceiveProps，componentWillUpdate）
   3. React16并没有删除这三个钩子函数，但是不能和新增的钩子函数（getDerivedStateFromProps、getSnapshotBeforeUpdate）混用，React17将会删除componentWillMount、componentWillReceiveProps，componentWillUpdate
   4. 新增了对错误的处理（componentDidCatch）

   

## 四、✨组件通信

### 1. 父子组件的通信方式?

props/事件触发

### 2. 跨级组件的通信方式?

   Context,redux/mobx,props

### 3. 非嵌套关系组件的通信方式?

   Subscribe, redux/mobx,通过共同的父节点

### 4. 如何解决props层级过深的问题

   使用contextApi,redux/mobx

### 5. 组件通信的方式有哪些

⽗组件向⼦组件通讯: ⽗组件可以向⼦组件通过传 props 的⽅式，向⼦组件进⾏通讯 

● ⼦组件向⽗组件通讯: props+回调的⽅式，⽗组件向⼦组件传递props进⾏通讯，此props为作⽤域为⽗组件⾃身的函 数，⼦组件调⽤该函数，将⼦组件想要传递的信息，作为参数，传递到⽗组件的作⽤域中 

● 兄弟组件通信: 找到这两个兄弟节点共同的⽗节点,结合上⾯两种⽅式由⽗节点转发信息进⾏通信 

● 跨层级通信: Context 设计⽬的是为了共享那些对于⼀个组件树⽽⾔是“全局”的数据，例如当前认证的⽤户、主题或⾸选语⾔，对于跨越多层的全局数据通过 Context 通信再适合不过 

● 发布订阅模式: 发布者发布事件，订阅者监听事件并做出反应,我们可以通过引⼊event模块进⾏通信 

● 全局状态管理⼯具: 借助Redux或者Mobx等全局状态管理⼯具进⾏通信,这种⼯具会维护⼀个全局状态中⼼Store,并根据不同的事件产⽣新的状态

## 五、🐒路由

1. React- Router的实现原理是什么?
2. 如何配置React- Router实现路由切换
3. React-Router怎么设置重定向?
4. react-router里的Link标签和a标签.
5. React-Router如何获取URL的参数和...
6. React- Router 4怎样在路由变化时重...
7. React-Router的路由有几种模式?
8. React- Router 4的Switch有什么用? 

## 六、✨Redux 

<img src="http://ww1.sinaimg.cn/large/005NUwyggy1gt4z7z98z3j60zk0k078s02.jpg" alt="redux原理图.png" style="zoom:33%;" />

### 1. 对Redux的理解，主要解决什么问题

单纯的Redux只是一个状态机，是没有UI呈现的，react- redux作用是将Redux的状态机和React的UI呈现绑定在一起，当你dispatch action改变state的时候，会自动更新页面。

### 2. Redux原理及工作流程

   - 首先，用户（通过View）发出Action，触发方式就用到了dispatch方法 

   - 然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State 

   - State—旦有变化，Store就会调用监听函数，来更新View

### 3. 🐒Redux中异步的请求怎么处理

   使用redux-thunk,redux-saga

### 4. Redux怎么实现属性传递，介绍下原理

   ![image-20210906140838237](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906140838237.png)

### 5. Redux中间件是什么?🐒接受几个参数?柯里化函数两端的参数具体是什么？

   - redux-thunk：用于异步操作

   - redux-logger：用于日志记录

     Redux 的中间件提供的是位于 action 被发起之后，到达 reducer 之前的扩展点，换而言之，原本 view -> action -> reducer -> store 的数据流加上中间件后变成了 view -> action -> middleware -> reducer -> store ，在这一环节可以做一些"副作用"的操作，如异步请求、打印日志等。

### 6. 🐒Redux请求中间件如何处理并发

### 7. Redux状态管理器和变量挂载到winddow中有什么区别？

   两者都是存储数据以供后期使用。但是Redux状态更改可回溯——Time travel，数据多了的时候可以很清晰的知道改动在哪里发生，完整的提供了一套状态管理模式。

### 8. mobx和redux有什么区别?

   共同点：

   1. 为了解决状态管理混乱
   2. 操作更新状态方式统一
   3. 支持将store与react组件连接

   区别：

   1. redux将数据保存在单一的store中，mobx将数据保存在分散的多个store中
   2. mobx中有更多的抽象和封装，调试会比较困难，同时结果也难以预测;而redux提供能够进行时间回溯的开发工具，同时其纯函数以及更少的抽象，让调试变得更加的容易
   3. redux使用不可变状态，这意味着状态是只读的，不能直接去修改它，而是应该返回一个新的状态，同时使用纯函数;mobx中的状态是可变的，可以直接对其进行修改

9. Redux和Vuex有什么区别，它们的共同思想

   vuex 弱化 dispatch，通过commit进行 store状态的一次更变；取消了action概念，不必传入特定的 action形式进行指定变更；弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易;

   redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案

### 10. Redux中间件是怎么拿到store和action?然后怎么处理？

![image-20210906142540730](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906142540730.png)

### 11. Redux中的connect有什么作用

connect负责连接React和Redux，可以获取整个store tree上的所有state，可以监听store tree的变化。

## 七、✨Hooks

### 3. getDerivedStateFromProps React 16.X中props改变后在哪个生命周期中处理？

   在getDerivedStateFromProps中进行处理。

第二种场景是一些组件需要在用户输入时有一个中间状态，当触发某个操作时再把中间结果提交给上层。以一个 `input`为例，在过去我们通过 `componentWillReceiveProps`在上层组件触发重绘时把数据同步到 `state`：

   ```js
   static getDerivedStateFromProps(nextProps, prevState) {
       const {type} = nextProps;
       // 当传入的type发生变化的时候，更新state
       if (type !== prevState.type) {
           return {
               type,
           };
       }
       // 否则，对于state不进行任何操作
       return null;
   }
   ```

### 4. React性能优化在哪个生命周期?优化的原理是什么？

shouldComponentUpdate提供了两个参数nextProps和nextState，表示下一次props和下一次state的值，当函数返回false时候，render()方法不执行，组件也就不会渲染，返回true时，组件照常重渲染。此方法就是拿当前props中值和下一次props中的值进行对比，数据相等时，返回false，反之返回true。



### 1. 对React Hook的理解，它的实现原理是什么？

   Hook是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。通过自定义hook，可以复用代码逻辑。

   `Hook` 是 React 16.8 的新增特性。它可以让你在不编写 `class` 的情况下使用 `state` 以及其他的 `React` 特性，在以前，函数组件也被称为无状态的组件，只负责渲染的一些工作。因此，现在的函数组件也可以是有状态的组件，内部也可以维护自身的状态以及做一些逻辑方面的处理。

   - useState

   - useEffect

   - useReducer

   - useCallback

   - useMemo

   - useRef


### 2. 为什么useState要使用数组而不是对象

   useState 返回的是 array 而不是 object 的原因就是为了降低使用的复杂度，返回数组的话可以直接根据顺序解构，而返回对象的话要想使用多次就需要定义别名了。

### 3. React Hooks解决了哪些问题?

   1. 可以使用 Hook 从组件中提取状态逻辑，使得这些逻辑可以单独测试并复用。
   2. `hooks`能够更容易解决状态相关的重用的问题

   通过对上面的初步认识，可以看到`hooks`能够更容易解决状态相关的重用的问题：

   - 每调用useHook一次都会生成一份独立的状态
   - 通过自定义hook能够更好的封装我们的功能

   编写`hooks`为函数式编程，每个功能都包裹在函数中，整体风格更清爽，更优雅

   hooks`的出现，使函数组件的功能得到了扩充，拥有了类组件相似的功能，在我们日常使用中，使用`hooks`能够解决大多数问题，并且还拥有代码复用机制，因此优先考虑`hooks

### 4. React Hook的使用限制有哪些?

   1. 不要在循环、条件或嵌套函数中调用 Hook；

   2. 在 React 的函数组件中调用 Hook。

### 5. useEffect与useLayoutEffect的区别

   1. 都是处理副作用的
   2. useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景；而 useLayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。

### 6. React Hooks在平时开发中需要注意的

   1. 不要在循环，条件或嵌套函数中调用Hook，必须始终在 React函数的顶层使用Hook

   2. 使用useState时候，使用push，pop，splice等直接更改数组对象的坑

   3. useState设置状态的时候，只有第一次生效，后期需要更新状态，必须通过useEffect

   4. 善用useCallback

      死循环产生的解决，父组件传递给子组件事件句柄时，如果我们没有任何参数变动可能会选用useMemo。但是每一次父组件渲染子组件即使没变化也会跟着渲染一次。

   5. 不要滥用useContext

      因为会破坏组件独立性，可以使用基于useContext封装的状态管理工具。

### 7. React Hooks和生命周期的关系?

   Hooks 组件（使用了Hooks的函数组件）有生命周期，而函数组件（未使用Hooks的函数组件）是没有生命周期的。

   ![image-20210906144816223](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906144816223.png)

### 8. useCallback 和 useMemo的区别

![image-20210908132743370](/Users/chenruo/Library/Application Support/typora-user-images/image-20210908132743370.png)

useMemo 和 useCallback 接收的参数都是一样,第一个参数为回调 第二个参数为要依赖的数据

共同作用：

1.仅仅 依赖数据 发生变化, 才会重新计算结果，也就是起到缓存的作用。

两者区别：

1.useMemo 计算结果是 return 回来的值, 主要用于 缓存计算结果的值 ，应用场景如： 需要 计算的状态

2.useCallback 计算结果是 函数, 主要用于 缓存函数，应用场景如: 需要缓存的函数，因为函数式组件每次任何一个 state 的变化 整个组件 都会被重新刷新，一些函数是没有必要被重新刷新的，此时就应该缓存起来，提高性能，和减少资源浪费。

注意： 不要滥用会造成性能浪费，react中减少render就能提高性能，所以这个仅仅只针对缓存能减少重复渲染时使用和缓存计算结果。

## 八、✨虚拟DOM

### 1. 对虚拟DOM的理解？虚拟DOM主要做了什么？其本身是什么？

从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。

### 2. 🐒React diff 算法的原理是什么?

   ![image-20210906152637422](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906152637422.png)

### 3. React key是干嘛用的为什么要加? key主要解决那一类的问题？

Keys 是 React 用于追踪哪些列表中元素被修改、被添加或者被移除的辅助标识。在开发过程中，我们需要保证某个元素的 key 在其同级元素中具有唯一性。

### 4. 虚拟DOM的引入与直接操作原生DOM,相比，哪一个效率更高？

### 5. React与Vue的diff算法有何不同?

![image-20210907130534095](/Users/chenruo/Library/Application Support/typora-user-images/image-20210907130534095.png)

## 九、其他

### 1. React组件命名推荐的方式是哪个?

   TodoApp

### 2. react最新版本解决了什么问题，增加了哪些东西？

   <img src="/Users/chenruo/Library/Application Support/typora-user-images/image-20210906152927763.png" alt="image-20210906152927763" style="zoom:150%;" />

   关于hooks，增加了很多hooks,使函数组件更容易操作

### 3. 🐒react实现一个全局的dialog

### 4. React数据持久化有什么实践吗?

  redux-persist。redux-persist会将redux的store中的数据缓存到浏览器的localStorage中。

### 5. 对React和Vue的理解，它们的异同

  ![image-20210906153501793](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906153501793.png)

  数据流，虚拟Dom，组件化写法不同

### 6. 可以使用TypeScript写React应用吗?

### 7. 🐒React设计思路，它的理念是什么?

### 8. React中props .children和React.Children的区别

   在React中，当涉及组件嵌套，在父组件中使用props.children把所有子组件显示出来。

   如果想把父组件中的属性传给所有的子组件，需要使用React.Children方法。

### 9. React的状态提升是什么?使用场景有哪些？

   概括来说就是将多个组件需要共享的状态提升到它们最近的父组件上，在父组件上改变这个状态然后通过props分发给子组件。

### 10. React中constructor和getlnitialState的区别

两者都是用来初始化state的。前者是ES6中的语法，后者是ES5中的语法，新版本的React中已经废弃了该方法。

### 11. React的严格模式如何使用，有什么用处？

![image-20210906154354133](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906154354133.png)

![image-20210906154407089](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906154407089.png)

### 12. 在React中遍历的方法有哪些?

数组->map,forEach,对象->map ,for in

### 13. 在React中页面重新加载时怎样保留数据？

![image-20210906154605356](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906154605356.png)

### 14. 同时引用这三个库react.js、react-dom.js,babel.js他们有是那么作用？

- react：包含react所必须的核心代码 

- react-dom：react渲染在不同平台所需要的核心代码 
- babel：将jsx转换成React代码的工具

### 15. React必须使用JSX吗?

![image-20210906154803293](/Users/chenruo/Library/Application Support/typora-user-images/image-20210906154803293.png)

### 16. 为什么使用jsx的组件中没有看到使用react却需要引入react？

### 17. 在React中怎么使用async/await?

async/await是ES7标准中的新特性。如果是使用React官方的脚手架创建的项目，就可以直接使用。

### 18. React.Children.map和js的map有什么区别？

JavaScript中的map不会对为null或者undefined的数据进行处理，而React.Children.map中的map可以处理React.Children为null或者undefined的情况。

### 19. 🐒对React SSR的理解

### 20. 为什么React要用JSX?

JSX 是一个 JavaScript 的语法扩展，或者说是一个类似于 XML 的 ECMAScript 语法扩展。它本身没有太多的语法定义，也不期望引入更多的标准。React 团队并不想引入 JavaScript 本身以外的开发体系。而是希望通过合理的关注点分离保持组件开发的纯粹性。

### 21. 🐒HOC相比mixins有什么优点?

### 22. React中的高阶组件运用了什么设计模式？

装饰模式。装饰模式的特点是不需要改变被装饰对象 本身，而只是在外面套一个外壳接口。JavaScript 目前已经有了原生装饰器的提案，

# 四、网络协议

## 一、HTTP协议

### 为什么会跨域

跨域，指的是浏览器不能执行其他网站的脚本。 它是由浏览器的同源策略造成的，是浏览器对JavaScript施加的安全限制。 请注意：localhost和127.0.0.1虽然都指向本机，但也属于跨域。 浏览器执行javascript脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行

**所谓同源是指，域名，协议，端口均相同，**



1. GET和POST的请求的区别
2. POST和PUT请求的区别
3.常见的HTTP请求头和响应头
4. HTTP状态码304是多好还是少好
5.常见的HTTP请求方法
6. OPTIONS请求方法及使用场景
7. HTTP 1.0和HTTP 1.1之间有哪些... 
8. HTTP 1.1和HTTP 2.0的区别
9. HTTP和HTTPS协议的区别
10. GET方法URL长度限制的原因
11.当在浏览器中输入Google.com并...
12.对keep-alive的理解
13.页面有多张图片，HTTP是怎样的加....
14. HTTP2的头部压缩算法是怎样的?
15. HTTP请求报文的是什么样的?
16. HTTP响应报文的是什么样的?
17. HTTP协议的优点和缺点
18.说一下HTTP 3.0
19. HTTP协议的性能怎么样
20. URL有哪些组成部分
21.与缓存相关的HTTP请求头有哪些
22.端口号的作用

## 二、HTTPS协议

1.什么是HT TPS协议?
2. TLS/SSL的工作原理
3.数字证书是什么? 
4. HTTPS通信(握手)过程
5. HTTPS的特点
6. HTTPS是如何保证安全的?

## 三、HTTP状态码

1. 2XX (Success成功状态码)
2.3XX (Redirection重定向状态码)
3.4XX (Client Error客户端错误状态码)
4.5XX (Server Error服务器错误状态码)
5.总结
6.同样是重定向，
307，303, 302的区..

## 四、DNS协议介绍

1. DNS协议是什么
2. DNS同时使用TCP和UDP协议?
3. DNS完整的查询过程
4.迭代查询与递归查询
5. DNS记录和报文

## 五、网络模型

▼1. OSI七层模型
(1)应用层
(2) 表示层
(3) 会话层
(4)传输层
(5)网络层
(6)数据链路层
(7)物理层

2. TCP/IP五层协议

## 六、TCP与UDP

1. TCP和UDP的概念及特点
2. TCP和UDP的区别
3. TCP和UDP的使用场景
4. UDP协议为什么不可靠? 
5. TCP的重传机制
6. TCP的拥塞控制机制
7. TCP的流量控制机制
8. TCP的可靠传输机制
9. TCP的三次握手和四次挥手
10. TCP粘包是怎么回事，如何处理?
11.为什么udp不会粘包?

## 七、WebSocket

1.对WebSocket的理解
2.即时通讯的实现:短轮询、长轮询、S.

# 五、性能优化

## 一、CDN

1. CDN的概念

2. CDN的作用

3. CDN的原理

4. CDN的使用场景

   使用第三方cdn服务

   使用CDN静态资源缓存

   直播传送

   

## 二、懒加载

1.懒加载的概念
2.懒加载的特点
3.懒加载的实现原理
4.懒加载5预加载的区别

## 三、回流与重绘

1.回流与重绘的概念及触发条件
2.如何避免回流与重绘?
3.如何优化动画?

4. documentFragment是什么?用它跟...

## 四、节流与防抖

1.对节流与防抖的理解
2.实现节流函数和防抖函数

## 五、图片优化

1.如何对项目中的图片进行优化?
2.常见的图片格式及使用场景

## 六、Webpack优化

1.如何提高webpack的打包速度?
(1)优化Loader
(2) HappyPack
(3) DlIPlugin
(4)代码压缩
(5)其他

2. 如何减少Webpack打包体积
   (1)按需加载
   (2) Scope Hoisting
   (3) Tree Shaking
   3.如何用webpack来优化前端性能?
   4.如何提高webpack的构建速度?











